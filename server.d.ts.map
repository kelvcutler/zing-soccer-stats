{"version":3,"sources":["../aaswZing/Zing/data/ServerContext.ts","../aaswZing/Zing/share/DB.ts","../aaswZing/Zing/data/UserManager.ts","../aaswZing/Zing/data/RightsManager.ts","../aaswZing/Zing/data/Query.ts","../aaswZing/Zing/data/DataSource.ts","../aaswZing/Zing/data/DataObj.ts","../aaswZing/Zing/data/MemDataSource.ts","../aaswZing/Zing/data/MongoDataSource.ts","../aaswZing/Zing/data/ZingEnv.ts","../aaswZing/Zing/data/ZingExpress.ts","models/ZPerson.ts","models/Person.ts","models/ZTeam.ts","models/Team.ts","models/ZPlayer.ts","models/Player.ts","models/ZGameEvent.ts","models/GameEvent.ts","models/ZGame.ts","models/Game.ts","models/ZMake.ts","SoccerStatsEnv.ts","common/AllRightsManager.ts","server/main.ts","../aaswZing/Zing/data/serverRefs.ts"],"names":[],"mappings":"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","file":"server.d.ts","sourcesContent":["\nclass ServerContext{\n    request:any;\n    response:any;\n    isLogin:boolean;\n    constructor(request,response){\n        this.request=request;\n        this.response=response;\n        this.isLogin=false;\n    }\n    setUserKey(userKey:string){\n        this.response.cookie(\"currentUserKey\",userKey);\n    }\n    getUserKey():string {\n        let key = this.request.cookies[\"currentUserKey\"];\n        return key;\n    }\n}","/**\n* The DB module contains some basic debugging aids. In particular\n* it provides mechanisms for writing outputs to the console log so that they appear in \n* a nested outline.\n*/\nmodule DB {\n    function quiet():boolean{\n        try {\n            if (process.env.DB==\"quiet\")\n                return true;\n        } catch (e){\n            return false;\n        }\n        return false;\n    }\n    var level = 0;\n    /**\n    * This will open a new level of indentation\n    * @param message is the message to be output with the level header\n    * @param obj an optional object that will be provided with the header.\n    * In many browsers this object can be opened and explored in depth by the debugger.\n    */\n    export function start(message: string, obj?: any) {\n        if (quiet()) return\n        if (dbon) {\n            msg(\">\" + message, obj);\n            level++;\n        }\n    }\n    /**\n    * This will output a message at the current level of indentation\n    * @param message is the message to be output \n    * @param obj an optional object that will be provided with the message.\n    * In many browsers this object can be opened and explored in depth by the debugger.\n    */\n    export function end(message: string, obj?: any) {\n        if (quiet()) return\n        if (dbon) {\n            level--;\n            if (level < 0)\n                level = 0;\n            msg(\"<\" + message, obj);\n        }\n\n    }\n    var dbop:boolean=false;\n    export function dbOnPage(db:boolean){\n        dbop=db;\n    }\n    /**\n    * This will close a level of indentation\n    * @param message is the message to be output with the level footer\n    * @param obj an optional object that will be provided with the footer.\n    * In many browsers this object can be opened and explored in depth by the debugger.\n    */\n    export function msg(message: string, obj?: any) {\n        if (quiet()) return\n        if (dbon) {\n            var pre = \"\";\n            for (var i = 0; i < level; i++) {\n                pre += \"   \";\n            }\n            if (obj)\n                console.log(pre + message, obj);\n            else\n                console.log(pre + message);\n            if (dbop){\n                let span = document.createElement(\"div\");\n                span.innerHTML=pre+message;\n                span.style.cssText=\"width:100%\";\n                let dbout = document.getElementById(\"dbout\");\n                if (dbout)\n                    dbout.append(span);\n            }\n        }\n    }\n\n    export function stackTrace(message: string) {\n        if (quiet()) return\n        try {\n            throw new Error(message);\n        } catch (e) {\n            console.log(e);\n        }\n    }\n    var dbon: boolean = true;\n    /**\n    * turns on debugging messages\n    */\n    export function on(msg: string) {\n        dbon = true;\n        start(\"+++\" + msg);\n    }\n    /**\n    * turns off debugging messages\n    */\n    export function off(msg: string) {\n        end(\"---\" + msg);\n        dbon = false;\n    }\n    var dbCounts = {};\n    export function count(name:string) {\n    \tlet count = dbCounts[name];\n    \tif (count)\n    \t\tcount++;\n    \telse\n    \t\tcount=1;\n    \tdbCounts[name]=count;\n    }\n    export function showCount(name:string){\n    \tlet count = dbCounts[name];\n    \tif (!count) count=0;\n    \tDB.msg(name,count);\n    }\n    export function showCounts(msg?:string){\n    \tlet m:string = \"counts \";\n    \tif (msg) m+=msg;\n    \tDB.start(m);\n    \tfor (let name in dbCounts){\n    \t\tDB.showCount(name);\n    \t}\n    \tDB.end(m);\n    }\n    export function clearCounts(name?:string){\n    \tif (name){\n    \t\tdbCounts[name]=0;\n    \t} else {\n    \t\tfor (let key in dbCounts){\n    \t\t\tDB.clearCounts(key);\n    \t\t}\n    \t}\n    }\n    var autoInterval=null;\n    export function countsAutoShow(millis:number){\n    \tif (autoInterval)\n    \t\tautoInterval.clearInterval();\n    \tautoInterval = setInterval(()=>{\n    \t\tDB.showCounts();\n    \t},millis);\n    }\n    export function noCountsAutoShow(){\n    \tclearInterval(autoInterval);\n    }\n\n}","class UserManager {\n    protected currentUserName:string;\n    dataSource:DataSource;\n    protected currentUserKey:string;\n    constructor(){\n        this.currentUserName=null;\n        this.dataSource=null;\n        this.currentUserKey=null;\n    }\n    get userName():string { return this.currentUserName}\n    login(userName:string,password:string,done:(err:string,user:DataObj)=>void,\n            serverContext:ServerContext){\n        if (this.dataSource.isRemote()){\n            this.dataSource.httpLogin(userName,password,(err:string,user:DataObj)=>{\n                if (err) {\n                    done(err,null);\n                } else {\n                    this.currentUserName=userName;\n                    this.currentUserKey=user._key;\n                    done(null,user);\n                }\n            });\n        }else {\n            this.currentUserName=userName;\n            this.currentUserKey=null;\n            done(null,null);\n        }\n    }\n\n    logout(done:(err:string)=>void){\n        if (this.dataSource.isRemote()){\n            this.dataSource.httpLogout((err:string)=>{\n                if (err) {\n                    done(err);\n                } else {\n                    this.currentUserName=null;\n                    this.currentUserKey=null;\n                    done(null);\n                }\n            })\n        } else {\n            this.currentUserName=null;\n            this.currentUserKey=null;\n            done(null)\n        }\n    }\n    createUser(userDesc:any,password:string,done:(err:string)=>void,\n            serverContext:ServerContext){\n        done(null);\n    }\n    getUserKey(serverContext?:ServerContext):string{\n        if (serverContext){\n            return serverContext.getUserKey();\n        } else {\n            return this.currentUserKey;\n        }\n    }\n    getUser(done:(user:DataObj)=>void,serverContext?:ServerContext) {\n        let userKey = this.getUserKey(serverContext);\n        this.dataSource.GET(userKey,(err:string,user:DataObj)=>{\n            done(user);\n        },false,serverContext);\n    }\n    serverSideLogin(userName:string,password:string,serverContext:ServerContext,done:(err:string,user:DataObj)=>void){\n        DB.msg(\"serverSideLogin not implemented for this \",this);\n        done(\"no serverside login\",null);\n    }\n    serverSideLogout(serverContext:ServerContext,done:(err:string)=>void){\n        DB.msg(\"serverSideLogout not implemented for this \",this);\n        done(\"no serverside logout\");\n    }\n}","/// <reference path=\"UserManager.ts\"/>\n/// <reference path=\"ServerContext.ts\"/>\n/// <reference path=\"DataObj.ts\"/>\n\nabstract class RightsManager {\n    dataSource: DataSource;\n    userManager: UserManager;\n    constructor(dataSource: DataSource, userManager: UserManager) {\n        this.dataSource = dataSource;\n        this.userManager = userManager;\n        this.userManager.dataSource = this.dataSource;\n    }\n    /* Each of these methods verifies the ability for the current user\n        to execute the corresponding method on the DataSource.\n        If there are no problems, then null is returned.\n        Otherwise a descriptive message string is returned showing the violation\n    */\n\n    abstract checkGET(key: string, serverContext: ServerContext, done: (granted: boolean) => void);\n    checkGETm(keys: string[], serverContext: ServerContext, done: (granted: boolean) => void) {\n        this.checkAllGET(keys, 0, serverContext, done);\n    }\n    abstract checkGETBlob(blobKey: string, serverContext, done: (granted: boolean) => void);\n    abstract checkPUT(obj: DataObj, serverContext: ServerContext, done: (granted: boolean) => void);\n    checkPUTm(objs: DataObj[], serverContext: ServerContext, done: (granted: boolean) => void) {\n        this.checkAllPUT(objs, 0, serverContext, done);\n    }\n    abstract checkPUTBlob(serverContext: ServerContext, done: (granted: boolean) => void);\n    abstract checkDELETE(key: string, serverContext: ServerContext, done: (granted: boolean) => void);\n    abstract checkFIND(typeCode: string, search: Query, serverContext: ServerContext, done: (granted: boolean) => void);\n    login(userId: string, password: string, done: (err: string, user: DataObj) => void, serverContext: ServerContext) {\n        if (this.userManager)\n            this.userManager.login(userId, password, done, serverContext);\n        else\n            done(\"RightsManager has no UserManager to login\", null);\n    }\n    createUser(userDesc: any, password: string, done: (err: string) => void, serverContext: ServerContext) {\n        if (this.userManager)\n            this.userManager.createUser(userDesc, password, done, serverContext);\n        else\n            done(\"RightsManager has no UserManager to create user\");\n    }\n\n    protected checkAllGET(keys: string[], idx: number, serverContext: ServerContext, done: (granted: boolean) => void) {\n        if (idx >= keys.length) {\n            done(true);\n        } else {\n            let obj = keys[idx];\n            this.checkGET(obj, serverContext, (granted: boolean) => {\n                if (granted) {\n                    this.checkAllGET(keys, idx + 1, serverContext, done);\n                } else {\n                    done(false);\n                }\n            })\n        }\n    }\n    protected checkAllPUT(objs: DataObj[], idx: number, serverContext: ServerContext, done: (granted: boolean) => void) {\n        if (idx >= objs.length) {\n            done(true);\n        } else {\n            let obj = objs[idx];\n            this.checkPUT(obj, serverContext, (granted: boolean) => {\n                if (granted) {\n                    this.checkAllPUT(objs, idx + 1, serverContext, done);\n                } else {\n                    done(false);\n                }\n            })\n        }\n    }\n}","/** \n * These objects can be used to create queries that can be used in searches\n */\n\ntype QueryValue = number |string | boolean | Query\ntype NumberQuery = number | Query;\ntype StringQuery = string | Query;\ntype BooleanQuery = boolean | Query;\nclass Query{\n    exp:any;\n    private constructor(exp:any){\n        this.exp=exp;\n    }\n    static OR(options:QueryValue[]):Query{\n        let desc = { $$:\"OR\", options: options }\n        return new Query(desc);\n    }\n    static AND(options:QueryValue[]):Query{\n        return new Query ({ $$:\"AND\",options:options})\n    }\n    static range(from:QueryValue,to:QueryValue):Query{\n        return new Query({ $$:\"RANGE\", from:from,to:to})\n    }\n    static anything():Query{\n        return new Query({$$:\"ANY\"})\n    }\n    static dict(desc:{[attName:string]:QueryValue}):Query{\n        let d:any ={$$:\"DICT\"};\n        for (let k in desc){\n            d[k]=desc[k];\n        }\n        return new Query(d)\n    }\n    static is(value:number|string|boolean):Query{\n        return new Query( { $$:\"IS\",value:value})\n    }\n    static listContains(query:QueryValue):Query{\n        return new Query( {$$:\"LC\",query:query})\n    }\n    static match(q1:QueryValue,q2:QueryValue):boolean{\n        if (!q1)\n            if (!q2) return true;\n            else return false;\n        else\n            if (!q2) return false;\n        if (typeof q1 != typeof q2) return false;\n        switch(typeof q1){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n                return q1==q2;\n            default:{\n                return this.matchQuery(<Query>q1,<Query>q2);\n            }\n        }\n    }\n    matches(val:any):boolean{\n        if (val instanceof DataObj) return this.matchesDO(val);\n        switch(this.exp.$$){\n            case \"OR\":\n                for (let i in this.exp.options){\n                    let opt = this.exp.options[i];\n                    if (Query.matchesQV(opt,val)) return true;\n                }\n                return false;\n            case \"AND\":\n                for (let i in this.exp.options){\n                    let opt = this.exp.options[i];\n                    if (!Query.matchesQV(opt,val)) return false\n                }\n                return true;\n            case \"RANGE\":\n                return this.rangeMatch(this.exp.from,this.exp.to,val);\n            case \"ANY\":\n                return true;\n            case \"DICT\":\n                return this.dictMatch(this.exp,val);\n            case \"IS\":\n                return this.exp.value == val;\n            case \"LC\":\n                for (let i in val){\n                    let v = val[i];\n                    if (Query.matchesQV(this.exp.query,v)) return true;\n                }\n                return false;\n\n        }\n    }\n    static matchesQV(qv:QueryValue,val:any):boolean{\n        switch(typeof qv){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n                return qv == val;\n            default:\n                return qv.matches(val);\n        }\n    }\n    attribute(attName:string):number | string | boolean | Query{\n        if (this.exp.$$ != \"DICT\") return null;\n        let att = this.exp[attName];\n        return att;\n    }\n\n    toJSON():any{\n        let src = this.exp;\n        let rslt:any = { $$:src.$$ }\n        switch(this.exp[\"$$\"]){\n            case \"OR\":\n            case \"AND\":\n                rslt.options = this.queryValueListToJSON(src.options)\n                break;\n            case \"RANGE\":\n                rslt.from = this.queryValueToJSON(src.from);\n                rslt.to = this.queryValueToJSON(src.to);\n                break;\n            case \"ANY\":\n                break;\n            case \"DICT\":\n                rslt=this.dictToJSON(src);\n                break;\n            case \"IS\":\n                rslt.value = this.queryValueToJSON(src.value);\n                break;\n            case \"LC\":\n                rslt.value = this.queryValueToJSON(src.query);\n                break;\n        }\n        return rslt;\n    }\n    \n    static fromJSON(json:any):QueryValue{\n        switch(typeof json){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n                return json;\n            default:\n                switch(json.$$){\n                    case \"OR\":\n                        return Query.OR(Query.listFromJSON(json.options));\n                    case \"AND\":\n                        return Query.AND(Query.listFromJSON(json.options));\n                    case \"RANGE\":\n                        return Query.range(Query.fromJSON(json.from),Query.fromJSON(json.to))\n                    case \"ANY\":\n                        return Query.anything();\n                    case \"DICT\":\n                        let dict = {};\n                        for (let i in json){\n                            if (i!=\"$$\"){\n                                dict[i]=Query.fromJSON(json[i]);\n                            }\n                        }\n                        return Query.dict(dict);\n                    case \"IS\":\n                        return Query.is(json.value)\n                    case \"LC\":\n                        return Query.listContains(Query.fromJSON(json.query))\n                }\n        }\n    }\n    private queryValueListToJSON(list:QueryValue[]):any{\n        let rslt = [];\n        for (let i in list){\n            let item = list[i];\n            rslt.push(this.queryValueToJSON(item))\n        }\n        return rslt;\n    }\n    private queryValueToJSON(val:QueryValue){\n        switch(typeof val){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n                return val;\n            default:\n                return val.toJSON();\n        }\n    }\n    private dictToJSON(desc:{[attName:string]:QueryValue}):any{\n        let rslt:any={ $$:\"DICT\"};\n        for (let i in desc){\n            rslt[i] = this.queryValueToJSON(desc[i])\n        }\n        return rslt;\n    }\n\n    private static listFromJSON(list:any[]):QueryValue[] {\n        let rslt:QueryValue[]=[];\n        for (let i in list){\n            let item = Query.fromJSON(list[i]);\n            rslt.push(item);\n        }\n        return rslt;\n    }\n\n    toMongo():any{\n        let rslt:any={};\n        \n        switch(this.exp.$$){\n            case \"OR\":\n                let oList:[]=this.mongoOptionsList(this.exp.options);\n                return { $or: oList }\n            case \"AND\":\n                return { $and: this.mongoOptionsList(this.exp.options)}\n            case \"RANGE\":\n                if (this.exp.from ){\n                    rslt.$gte = this.exp.from;\n                }\n                if (this.exp.to){\n                    rslt.$lte = this.exp.to;\n                }\n                return rslt;\n            case \"ANY\":\n                return { $exists: true};\n            case \"DICT\":\n                for (let i in this.exp){\n                    if (i!=\"$$\"){\n                        let v = this.exp[i];\n                        if (v) {\n                            if (v.exp && v.exp.$$ && v.exp.$$==\"DICT\"){\n                                Query.mongoCollapseDICT(rslt,i,v.exp);\n                            } else\n                                rslt[i]=Query.toMongoValue(v)\n                        } else if (v==0)\n                            rslt[i]=Query.toMongoValue(v)\n                    }\n                }\n                return rslt;\n            case \"IS\":\n                return this.exp.value;\n            case \"LC\":\n                return { $elemMatch: Query.toMongoValue(this.exp.query)}\n            default:\n                return { badoperator:this.exp.$$}\n        }\n    }\n    private static mongoCollapseDICT(rslt:{},key:string,v:{}){\n        for (let k in v){\n            if (k!=\"$$\"){\n                rslt[key+\".\"+k]=v[k];\n            }\n        }\n    }\n    private mongoOptionsList(options:QueryValue[]){\n        let rslt:any=[];\n        for (let i in options){\n            let option = options[i];\n            let mongOpt = Query.toMongoValue(option);\n            rslt.push(mongOpt);\n        }\n        return rslt;\n    }\n    private static toMongoValue(val:QueryValue){\n        switch(typeof val){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n                return val;\n            default:\n                return val.toMongo();\n        }\n    }\n    private static matchQuery(q1:Query,q2:Query):boolean{\n        if (q1.exp.$$ != q2.exp.$$) return false;\n        switch(q1.exp.$$){\n            case \"OR\":\n            case \"AND\":\n                return this.matchOptionLists(q1.exp.options,q2.exp.options)\n            case \"RANGE\":\n                return this.match(q1.exp.from,q2.exp.from) && this.match(q1.exp.to,q2.exp.to);\n            case \"ANY\":\n                return true;\n            case \"DICT\":\n                return this.matchDicts(q1.exp,q2.exp);\n            case \"IS\":\n                return q1.exp.value == q2.exp.value;\n            case \"LC\":\n                return this.match(q1.exp.query,q2.exp.query);\n            default:\n                DB.msg(\"matchQuery got invalid $$\",q1.exp.$$);\n                return false;\n        }\n    }\n    private static matchOptionLists(l1:QueryValue[],l2:QueryValue[]):boolean{\n        if (l1.length!=l2.length) return false;\n        for (let i in l1){\n            let q=l1[i];\n            if (!this.matchOptions(q,l2)) return false;\n        }\n        for (let i in l2){\n            let q=l2[i];\n            if (!this.matchOptions(q,l1)) return false;\n        }\n        return true;\n    }\n    private static matchOptions(q:QueryValue,list:QueryValue[]):boolean{\n        for (let i in list){\n            let lq = list[i];\n            if (this.match(q,lq)) return true;\n        }\n        return false;\n    }\n    private static matchDicts(d1:{},d2:{}):boolean{\n        for (let k in d1){\n            let a1=d1[k];\n            let a2=d2[k];\n            if (!this.match(a1,a2)) return false;\n        }\n        for (let k in d2){\n            let a1=d1[k];\n            let a2=d2[k];\n            if (!this.match(a1,a2)) return false;\n        }\n        return true;\n    }\n    \n    private rangeMatch(from,to,val){\n        let fromTrue = true;\n        if (from){\n            switch(typeof from){\n                case \"number\":\n                    fromTrue=from<=val;\n                    break;\n                case \"string\":\n                    fromTrue = from.localeCompare(val)>=0;\n                    break;\n                default:\n                    fromTrue=false;\n                    break;\n            }\n        }\n        let toTrue = true;\n        if (to){\n            switch(typeof to){\n                case \"number\":\n                    toTrue=val<=to;\n                    break;\n                case \"string\":\n                    toTrue = val.localeCompare(to)>=0;\n                    break;\n                default:\n                    toTrue=false;\n                    break;\n            }\n        }\n        return fromTrue && toTrue;\n    }\n    private dictMatch(dict:{[attName:string]:QueryValue},val):boolean{\n        if (typeof val != \"object\") return false;\n        for (let att in dict){\n            if (att!=\"$$\"){\n                let dVal = dict[att];\n                let vVal = val[att];\n                if (!Query.matchesQV(dVal,vVal)) return false;\n            }\n        }\n        return true;\n    }\n    \n    \n    matchesDO(obj:DataObj):boolean{\n        switch(this.exp.$$){\n            case \"OR\":\n                for (let i in this.exp.options){\n                    let opt = this.exp.options[i];\n                    if (Query.matchesQV(opt,obj)) return true;\n                }\n                return false;\n            case \"AND\":\n                for (let i in this.exp.options){\n                    let opt = this.exp.options[i];\n                    if (!Query.matchesQV(opt,obj)) return false\n                }\n                return true;\n            case \"RANGE\":\n                return false;// no ranges on DataObj\n            case \"ANY\":\n                return true;\n            case \"DICT\":\n                return this.dictMatchDO(this.exp,obj);\n            case \"IS\":\n                return false; // no is test for DataObj\n            case \"LC\":\n                return false; // no list contains on DataObj\n        }\n    }\n    private dictMatchDO(dict:{[attName:string]:QueryValue},obj:DataObj):boolean{\n        for (let att in dict){\n            if (att!=\"$$\"){\n                let dVal = dict[att];\n                let oVal = obj[\"get\"+att]();\n                if (!Query.matchesQV(dVal,oVal)) return false;\n            }\n        }\n        return true;\n    }\n}","/// <reference path=\"../share/DB.ts\"/>\n/// <reference path=\"DataObj.ts\"/>\n/// <reference path=\"RightsManager.ts\"/>\n/// <reference path=\"Query.ts\"/>\n\n/*type DataSearchRangeSpec = { from: string | number, to: string | number};\ntype NumberQuery = number | {from?:number,to?:number};\ntype StringQuery = string | {from?:string, to?:string};\ntype FieldQuery = NumberQuery | StringQuery | boolean;\ntype DataSearchSpec = { [fieldName:string]:FieldQuery}*/\ninterface DataMonitor {\n    notify();\n}\nclass DataSource {\n    private rightsManager_:RightsManager; // any will be replaced with actual interface later\n    private dataMonitor:DataMonitor;\n    constructor(){\n        DataObj.globalSource=this;\n    }\n    setDataMonitor(dataMonitor:DataMonitor){\n        this.dataMonitor=dataMonitor;\n    }\n    getRightsManager():RightsManager{\n        return this.rightsManager_;\n    }\n    setRightsManager(rm:RightsManager){\n        this.rightsManager_=rm;\n    }\n    isRemote():boolean { return false}\n    notify(){\n        if (this.dataMonitor) \n            this.dataMonitor.notify();\n    }\n    GET(key:string, done:(err:string,data:DataObj)=>void,forceRequest:boolean,\n            serverContext:ServerContext){\n        done(null,null);\n    }\n    canGet(key:string,serverContext:ServerContext,done:(granted:boolean)=>void){\n        let rm = this.rightsManager_;\n        if (rm){\n            rm.checkGET(key,serverContext,done);\n        } else {\n            done(false);\n        }\n    } \n    cGET(key:string,forceRequest?:boolean):DataObj{\n        DB.msg( \"cGET This data source has no caching\");\n        return null;\n    }\n    GETm(keys:string[],done:(err:string,data:DataObj[])=>void,forceRequest:boolean,\n            serverContext:ServerContext){\n        done(null,null);\n    }\n    canGETm(keys:string[],serverContext:ServerContext,done:(granted:boolean)=>void){\n        let rm=this.rightsManager_\n        if (rm){\n            rm.checkGETm(keys,serverContext,done);\n        } else {\n            done(false);\n        }\n    }\n    cGETm(keys:string[],forceRequest?:boolean):DataObj[]{\n        DB.msg( \"cGETm This data source has no caching\");\n        return null;\n    }\n    \n    PUT(obj:DataObj,done:(err:string,newObj:DataObj)=>void,serverContext:ServerContext){\n        done(null,null);\n    }\n    canPUT(obj:DataObj,serverContext:ServerContext,done:(granted:boolean)=>void){\n        let rm=this.rightsManager_;\n        if (rm){\n            rm.checkPUT(obj,serverContext,done);\n        } else {\n            done(false);\n        }\n    }\n    canGETBlob(blobKey:string,serverContext:ServerContext,done:(granted:boolean)=>void){\n        let rm=this.rightsManager_;\n        if(rm){\n            rm.checkGETBlob(blobKey,serverContext,done);\n        } else {\n            done(false);\n        }\n    }\n    GETBlob(blobKey:string,serverContext:ServerContext,done:(err:string,blob:BlobStoreRec)=>void){\n        DB.msg(\"data source has no downloadFile\",this);\n    }\n    canPUTBlob(serverContext:ServerContext,done:(granted:boolean)=>void){\n        let rm = this.rightsManager_;\n        if (rm){\n            rm.checkPUTBlob(serverContext,done);\n        } else {\n            done(false);\n        }\n    }\n    PUTBlob(blob:Blob,name:string,serverContext:ServerContext,done:(err:string,blobKey:string)=>void){\n        done(null,null);\n    }\n    PUTFileBlob(file:File,serverContext:ServerContext,done:(err:string,blobKey:string)=>void){\n        done(null,null);\n    }\n    PUTm(objs:DataObj[],done:(err:string,newObjs:DataObj[])=>void,serverContext:ServerContext){\n        done(null,null);\n    }\n    canPUTm(objs:DataObj[],serverContext:ServerContext,done:(granted:boolean)=>void){\n        let rm=this.rightsManager_;\n        if (rm){\n            rm.checkPUTm(objs,serverContext,done);\n        } else {\n            done(false);\n        }\n    }\n    DELETE(key:string,done?:(err:string)=>void){\n        done(null)\n    }\n    canDELETE(key:string,serverContext:ServerContext,done:(granted:boolean)=>void){\n        let rm=this.rightsManager_;\n        if (rm){\n            rm.checkDELETE(key,serverContext,done);\n        } else {\n            done(false);\n        }\n    }\n    FIND(typeCode:string, search:Query,done:(err:string,keys:string[],objs:DataObj[])=>void,\n            keysOnly:boolean,forceRequest:boolean,serverContext:ServerContext){\n        done(null,null,null);\n    }\n    protected getFromKeys(keys:string[],idx:number,objs:DataObj[],done:(objs:DataObj[])=>void,serverContext:ServerContext){\n        if (idx>=keys.length){\n            done(objs);\n        } else {\n            this.GET(keys[idx],(err:string,data:DataObj)=>{\n                if (!err){\n                    objs.push(data);\n                    this.getFromKeys(keys,idx+1,objs,done,serverContext);\n                }\n            },false,serverContext);\n        }\n    }\n    canFIND(typeCode:string,search:Query,serverContext:ServerContext,done:(granted:boolean)=>void){\n        let rm=this.rightsManager_;\n        if (rm){\n            rm.checkFIND(typeCode,search,serverContext,done);\n        } else {\n            done(false);\n        }\n    }\n    cFIND(typeCode:string,search:Query,keysOnly:boolean,forceRequest:boolean):string[]{\n        DB.msg( \"cFIND no caching on this data service\");\n        return null;\n    }\n    static collectionFromKey(key:string):string{\n        if (!key){\n            DB.msg(\"no key for collection\");\n            return \"\";\n        }\n        let parts = key.split(\"_\");\n        let typeCode = parts[0];\n        let colCode = DataObj.typeToCollection(typeCode);\n        return colCode;\n    }\n    static typeFromKey(key:string):string{\n        let parts = key.split(\"_\");\n        return parts[0];\n    }\n    static idFromKey(key:string):string {\n        let parts = key.split(\"_\");\n        return parts[1];\n    }\n    static generateKey(typeCode:string):string {\n        let id = Math.random()*1000000;\n        id = Math.floor(id);\n        return typeCode+\"_\"+id;\n    }\n    static filterKeyList(expectedCode:string, keyList:string[]):string[] {\n        let rslt:string[] = [];\n        for (let idx in keyList){\n            let key = keyList[idx];\n            let ty = DataSource.typeFromKey(key);\n            if (DataObj.checkTypeCode(expectedCode,ty)){\n                rslt.push(key);\n            }\n        }\n        return rslt;\n    }\n    touched(obj:DataObj):boolean{\n        this.notify();\n        return true;\n    }\n    login(userId:string,password:string,done:(err:string)=>void,serverContext?:ServerContext){\n        if (this.getRightsManager())\n            this.getRightsManager().login(userId,password,done,serverContext);\n        else\n            done(\"DataSource has no RightsManager to login\");\n    }\n    httpLogin(userId:string,password:string,done:(err:string,user:DataObj)=>void){\n        done(\"No httpLogin for this data source\",null);\n    }\n    httpLogout(done:(err:string)=>void){\n        done(\"No httpLogin for this data source\");\n    }\n    createUser(userDesc:any,password:string,done:(err:string)=>void,serverContext?:ServerContext){\n        if (this.getRightsManager())\n            this.getRightsManager().createUser(userDesc,password,done,serverContext);\n        else\n            done(\"DataSource has no RightsManager to create user\");\n    }\n\n}\n","/// <reference path=\"ServerContext.ts\"/>\n/// <reference path=\"./DataSource.ts\"/>\n\n\n//\nclass DataObj {\n\tprotected _type:string;\n\t_key:string;\n\tparent:DataObj;\n\tdataSource: DataSource;\n\tstatic globalSource:DataSource;\n\tprivate blockTouch_:boolean;\n\tconstructor (json:any){\n\t\tthis.blockTouch_=false;\n\t\tthis._type = this.getTypeCode();\n\t\tthis._key = json._key;\n\t\tif (!json._key && json._id){\n\t\t\tthis._key = this.getTypeCode()+\"_\"+json._id;\n\t\t}\n\t\tthis.parent=null;\n\t}\n\t\n\tgetTypeCode():string{\n\t\treturn null;\n\t}\n\tgetDataSource():DataSource{\n\t\tif (this.dataSource)\n\t\t\treturn this.dataSource;\n\t\telse if (this.parent)\n\t\t\treturn this.parent.getDataSource();\n\t\telse if (DataObj.globalSource)\n\t\t\treturn DataObj.globalSource;\n\t\telse\n\t\t\treturn null;\n\t}\n\tgetUserManager():UserManager{\n\t\tlet ds = this.getDataSource();\n\t\tif (ds){\n\t\t\tlet rm = ds.getRightsManager();\n\t\t\tif (rm){\n\t\t\t\tlet um = rm.userManager;\n\t\t\t\treturn um;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\ttouch():boolean{ // touch will return false if any permissions are violated.\n\t\tif (this.blockTouch_) return true;\n\t\tif (this.dataSource){\n\t\t\tif (this.dataSource.touched(this)){ // the dataSource is the prime mechanism for permissions\n\t\t\t\tif (this.parent)\n\t\t\t\t\treturn this.parent.touch();\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.parent)\n\t\t\t\treturn this.parent.touch();\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tblockTouch(on:boolean){\n\t\tthis.blockTouch_=on;\n\t\tif(!on) this.touch();\n\t}\n\ttoJSON():any{\n        return null;\n\t}\n\tstatic GET(key:string, done:(err:string,newObj:DataObj)=>void,forceRequest:boolean,\n\t\t\tserverContext:ServerContext){\n\t\tlet ds = DataObj.globalSource;\n\t\tif (ds){\n\t\t\tds.canGet(key,serverContext,(granted:boolean)=>{\n\t\t\t\tif (granted){\n\t\t\t\t\tds.GET(key,done,forceRequest,serverContext);\n\t\t\t\t} else {\n\t\t\t\t\tdone(`ERR GET on ${key} had rights fail`,null);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tdone(`ERR GET on ${key} has no dataSource`,null);\n\t\t}\n\t}\n\tstatic cGET(key:string,forceRequest:boolean){\n\t\tlet ds=DataObj.globalSource;\n\t\tif (ds){\n\t\t\treturn ds.cGET(key,forceRequest);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tstatic GETm(keys:string[], done:(err:string,newObjs:DataObj[])=>void,forceRequest:boolean,\n\t\t\tserverContext:ServerContext){\n\t\tlet ds = DataObj.globalSource;\n\t\tif (ds){\n\t\t\tds.canGETm(keys,serverContext,(granted:boolean)=>{\n\t\t\t\tif (granted){\n\t\t\t\t\tds.GETm(keys,done,forceRequest,serverContext);\n\t\t\t\t} else {\n\t\t\t\t\tdone(`ERR GETm  had rights fail`,null);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tdone(`ERR GETm has no dataSource`,null);\n\t\t}\n\t}\n\t\n\tstatic cGETm(keys:string[],forceRequest?:boolean):DataObj[]{\n\t\tlet ds= DataObj.globalSource;\n\t\tif (ds){\n\t\t\treturn ds.cGETm(keys,forceRequest);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tGETFileBlob(blobKey:string,serverContext:ServerContext,done:(err:string,blob:BlobStoreRec)=>void){\n\t\tlet ds = this.getDataSource();\n\t\tif (ds){\n\t\t\tds.canGETBlob(blobKey,serverContext,(granted:boolean)=>{\n\t\t\t\tif (granted){\n\t\t\t\t\tds.GETBlob(blobKey,serverContext,done);\n\t\t\t\t} else {\n\t\t\t\t\tdone(\"ERR GETBlobFile had rights fail\",null);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tPUT(done:(err:string,newObj:DataObj)=>void,serverContext?:ServerContext){\n\t\tlet ds = this.getDataSource();\n\t\tif (ds){\n\t\t\tds.canPUT(this,serverContext,(granted:boolean)=>{\n\t\t\t\tif (granted){\n\t\t\t\t\tds.PUT(this,done,serverContext);\n\t\t\t\t} else {\n\t\t\t\t\tdone(`ERR PUT on ${this._key} had rights fail`,null);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tdone(`ERR PUT on ${this._key} has no dataSource`,null);\n\t\t}\n\t}\n\tstatic PUTFileBlob(file:File,done:(err:string,blobKey:string)=>void,serverContext?:ServerContext){\n\t\tlet ds=this.globalSource;\n\t\tif (ds){\n\t\t\tds.canPUTBlob(serverContext,(granted:boolean)=>{\n\t\t\t\tif (granted){\n\t\t\t\t\tds.PUTFileBlob(file,serverContext,done);\n\t\t\t\t} else {\n\t\t\t\t\tdone(`ERR PUTFileBlob  had rights fail`,null);\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\tdone(`ERR PUTFileBlob has no dataSource`,null);\n\t\t}\n\t}\n\tstatic PUTBlob(blob:Blob,name:string,done:(err:string,blobKey:string)=>void,serverContext?:ServerContext){\n\t\tlet ds=this.globalSource;\n\t\tif (ds){\n\t\t\tds.canPUTBlob(serverContext,(granted:boolean)=>{\n\t\t\t\tif (granted){\n\t\t\t\t\tds.PUTBlob(blob,name,serverContext,done);\n\t\t\t\t} else {\n\t\t\t\t\tdone(`ERR PUTFileBlob  had rights fail`,null);\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\tdone(`ERR PUTBlob has no dataSource`,null);\n\t\t}\t\t\n\t}\n\tstatic GETBlob(blobKey:string,serverContext:ServerContext,done:(err:string,blob:BlobStoreRec)=>void){\n\t\tlet ds=this.globalSource;\n\t\tif (ds){\n\t\t\tds.canGETBlob(blobKey,serverContext,(granted:boolean)=>{\n\t\t\t\tif (granted){\n\t\t\t\t\tds.GETBlob(blobKey,serverContext,done);\n\t\t\t\t} else {\n\t\t\t\t\tdone(`ERR getFileBlob had rights fail`,null);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n    }\n\tstatic PUTm(objs:DataObj[],done:(err:string, newObjs:DataObj[])=>void,serverContext:ServerContext){\n\t\tlet ds = this.globalSource;\n\t\tif (ds){\n\t\t\tds.canPUTm(objs,serverContext,(granted:boolean)=>{\n\t\t\t\tif (granted){\n\t\t\t\t\tds.PUTm(objs,done,serverContext);\n\t\t\t\t} else {\n\t\t\t\t\tdone(`ERR PUTm had rights fail`,null);\n\t\t\t\t}\n\t\t\t});\n\t\t}else {\n\t\t\tdone(`ERR PUTm  has no DataObj.globalSource`,null);\n\t\t}\n\t}\n\tDELETE(done?:(err:string)=>void,serverContext?:ServerContext){\n\t\tlet ds = this.getDataSource();\n\t\tif (ds){\n\t\t\tds.canDELETE(this._key,serverContext,(granted:boolean)=>{\n\t\t\t\tif (granted){\n\t\t\t\t\tds.DELETE(this._key,done);\n\t\t\t\t} else {\n\t\t\t\t\tdone(`ERR DELETE on ${this._key} has rights fail`);\n\t\t\t\t}\n\t\t\t})\t\n\t\t} else {\n\t\t\tdone(`ERR DELETE on ${this._key} has no dataSource`);\n\t\t}\n\t}\n\tstatic FIND(typeCode:string,search:Query,done:(err:string,keys:string[])=>void,\n\t\t\tkeysOnly:boolean,forceRequest:boolean,serverContext:ServerContext){\n\t\tlet ds=DataObj.globalSource;\n\t\tif (ds){\n\t\t\tds.canFIND(typeCode,search,serverContext,(granted:boolean)=>{\n\t\t\t\tif (granted){\n\t\t\t\t\tds.FIND(typeCode,search,done,keysOnly,forceRequest,serverContext);\n\t\t\t\t} else {\n\t\t\t\t\tdone(`ERR FIND on ${typeCode} had rights fail`,null);\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\tdone(`ERR FIND on ${typeCode} has no dataSource`,null);\n\t\t}\n\t}\n\tstatic cFIND(typeCode:string,search:Query,keysOnly:boolean,forceRequest:boolean):string[]{\n\t\tlet ds= DataObj.globalSource;\n\t\tif (ds){\n\t\t\treturn ds.cFIND(typeCode,search,keysOnly,forceRequest);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tstatic checkTypeCode(expectedType:string, receivedType:string):boolean{\n\t\tif (!expectedType) return true;\n\t\tif (!receivedType) return true;\n\t\treturn DataObj.canA[expectedType][receivedType];\n\t}\n\tstatic make:(expectedType:string,json:any)=>DataObj;\n\tstatic makeList:(expectedType:string,json:any[],parent:DataObj)=>DataObj[];\n\tstatic makeDict:(expectedType:string,json:any,parent:DataObj)=>{[k:string]:DataObj};\n\tprivate static classInfo_:DataObjClassInfo;\n\tstatic set classInfo(info:DataObjClassInfo){\n\t\tDataObj.classInfo_=info;\n\t\tDataObj.buildTypeToCollection();\n\t\tDataObj.buildCanAssign();\n\t}\n\tstatic get classInfo():DataObjClassInfo{\n\t\treturn DataObj.classInfo_;\n\t}\n\tprivate static tToC:{ [typeCode:string]:string};\n\tprivate static canA:{ [superCode:string]:{[typeCode:string]:boolean}};\n\tprivate static sRoots: { [rootClassName:string]:boolean}=null;\n\tprivate static buildTypeToCollection(){\n\t\tDataObj.tToC={};\n\t\tDataObj.sRoots={};\n\t\tfor ( let typeCode in DataObj.classInfo_){\n\t\t\tDataObj.tToC[typeCode]=DataObj.topSuperCode(typeCode);\n\t\t}\n\t}\n\tstatic typeCodeToName(typeCode:string){\n\t\tlet ci = this.classInfo[typeCode];\n\t\tlet cn = ci.className;\n\t\treturn cn;\n\t}\n\tstatic typeToCollection(typeCode:string){\n\t\treturn DataObj.tToC[typeCode];\n\t}\n\tstatic collections():{ [rootClassName:string]:boolean }{\n\t\treturn DataObj.sRoots;\n\t}\n\tprivate static topSuperCode(typeCode:string):string{\n\t\tlet ci = DataObj.classInfo_[typeCode];\n\t\tif (ci && ci.superCode && ci.superCode.length>0 && typeCode != ci.superCode){\n\t\t\treturn this.topSuperCode(ci.superCode);\n\t\t} else {\n\t\t\tDataObj.sRoots[typeCode]=true;\n\t\t\treturn typeCode;\n\t\t}\n\t}\n\tprivate static buildCanAssign(){\n\t\tDataObj.canA = {};\n\t\tfor (let typeCode in DataObj.classInfo_){\n\t\t\tDataObj.superCanAssign(typeCode,typeCode);\n\t\t}\n\t}\n\tprivate static superCanAssign(superCode,typeCode){\n\t\tlet ca = DataObj.canA;\n\t\tif (!ca[superCode])\n\t\t\tca[superCode]={};\n\t\tca[superCode][typeCode]=true;\n\t\tlet ci = DataObj.classInfo_[superCode];\n\t\tif (ci){\n\t\t\tlet sc = ci.superCode;\n\t\t\tif (sc && sc.length>0)\n\t\t\t\tthis.superCanAssign(sc,typeCode);\n\t\t}\n\t}\n\n}\n\ntype DataObjClassInfo = { \n\t[typeCode:string]:{ \n\t\tclassName:string, \n\t\tsuperCode?:string,\n\t\tkeyed:boolean,\n\t\tfields: {\n\t\t\t[fieldName:string]: { type:string, isList:boolean, isDict:boolean}\n\t\t}\n\t}\n}\n\ntype MongoBinary = any;\ntype BlobStoreRec = {\n\t_key?:string,\n\tname:string,\n\ttype:string,\n\tnextBlob?:string,\n\tdata: MongoBinary\n}","/// <reference path=\"DataSource.ts\"/>\n\nclass MemDataSource extends DataSource {\n    datastore:any;\n    constructor(){\n        super();\n        this.datastore={};\n    }\n\n    GET(key:string, done:(err:string,data:DataObj)=>void,forceRequest:boolean,\n            serverContext:ServerContext){\n        let _this=this;\n        \n        let collectionKey = DataSource.collectionFromKey(key);\n        let id = DataSource.idFromKey(key);\n        let collection = this.datastore[collectionKey];\n        if (!collection){\n            this.datastore[collectionKey]={}\n            collection = this.datastore[collectionKey];\n        }\n        let rec = collection[id];\n        if (rec) {\n            rec = DataObj.make(collectionKey,rec);\n            rec.dataSource=_this;\n            done(null,rec);\n        } else\n            done(\"key not found \"+key,null);\n        \n    }\n    cGET(key:string,forceRequest?:boolean):DataObj{\n        let collectionKey = DataSource.collectionFromKey(key);\n        let id = DataSource.idFromKey(key);\n        let collection = this.datastore[collectionKey];\n        if (!collection){\n            this.datastore[collectionKey]={}\n            collection = this.datastore[collectionKey];\n        }\n        let rec = collection[id];\n        if (rec) {\n            rec = DataObj.make(collectionKey,rec);\n            rec.dataSource=this;\n            return rec;\n        } else{\n            return null;\n        }\n    }\n    GETm(keys:string[], done:(err:string,data:DataObj[])=>void,forceRequest:boolean,\n            serverContext:ServerContext){\n        this.multiGet(0,keys,[],done,forceRequest);\n    }\n    private multiGet(idx:number,keys:string[],rslt:DataObj[],done:(err:string,data:DataObj[])=>void,forceRequest:boolean){\n        if (idx>=keys.length) {\n            done(null,rslt);\n        } else {\n            this.GET(keys[idx],(err:string,data:DataObj)=>{\n                if (err) {\n                    done(err,rslt);\n                } else {\n                    rslt.push(data);\n                    this.multiGet(idx+1,keys,rslt,done,forceRequest);\n                }\n            },forceRequest,null);\n        }\n    }\n    GETBlob(blobKey:string,serverContext:ServerContext,done:(err:string,blob:BlobStoreRec)=>void){\n\n        let collection = this.datastore[\"BLOB\"];\n        if (collection){\n            let file:File = collection[blobKey];\n            DB.msg(\"downloadFile memdatasource not done\",file);\n        }\n    }\n    cGETm(keys:string[],forceRequest?:boolean):DataObj[]{\n        let rslt:DataObj[] = [];\n        for (let i in keys){\n            let key = keys[i];\n            let obj = this.cGET(key,forceRequest);\n            if (obj)\n                rslt.push(obj);\n        }\n        return rslt;\n    }\n    PUT(obj:DataObj,done:(err:string,newObj:DataObj)=>void, serverContext:ServerContext){\n        \n        let _this=this;\n\n        let key = obj._key;\n        if (!key){\n            let tc = obj.getTypeCode();\n            key = DataSource.generateKey(tc);\n            obj._key=key;\n        }\n        let collectionKey = obj.getTypeCode();\n        let collection = this.datastore[collectionKey];\n        if (!collection){\n            this.datastore[collectionKey]={}\n            collection = this.datastore[collectionKey];\n        }\n        let id = DataSource.idFromKey(key);\n        collection[id]=obj.toJSON();\n        obj.dataSource = _this;\n        done(null,obj);\n    }\n    PUTm(objs:DataObj[],done:(err:string,newObjs:DataObj[])=>void,\n            serverContext:ServerContext){\n        this.multiPut(0,objs,[],done,serverContext);\n    }    \n    \n    private multiPut(idx:number,objs:DataObj[],rslt:DataObj[],done:(err:string,newObjs:DataObj[])=>void,\n            serverContext:ServerContext){\n        if (idx>=objs.length){\n            done(null,rslt);\n        } else {\n            this.PUT(objs[idx],(err:string,data:DataObj)=>{\n                if (err){\n                    done(err,rslt);\n                } else {\n                    rslt.push(data);\n                    this.multiPut(idx+1,objs,rslt,done,serverContext);\n                }\n            },serverContext)\n        }\n    }\n    PUTFileBlob(file:File,serverContext:ServerContext,done:(err:string,blobKey:string)=>void){\n        let key = DataSource.generateKey(\"BLOB\");\n        let collection = this.datastore[\"BLOB\"];\n        if (!collection){\n            this.datastore[\"BLOB\"]={};\n            collection = this.datastore[\"BLOB\"];\n        }\n        let id = DataSource.idFromKey(key);\n        collection[id]={ _id:id, _key:key, file:file};\n        done(null,key);\n    }\n    PUTBlob(blob:Blob,name:string,serverContext:ServerContext,done:(err:string,blobKey:string)=>void){\n        let key = DataSource.generateKey(\"BLOB\");\n        let collection = this.datastore[\"BLOB\"];\n        if (!collection){\n            this.datastore[\"BLOB\"]={};\n            collection = this.datastore[\"BLOB\"];\n        }\n        let id = DataSource.idFromKey(key);\n        collection[id]={ _id:id, _key:key, blob:blob};\n        done(null,key);\n    }\n    DELETE(key:string,done?:(err:string)=>void){\n        super.DELETE(key,(err:string)=>{\n            if (err) {\n                if(done) done(err);\n            } else {\n                let collectionKey = DataSource.collectionFromKey(key);\n                let id = DataSource.idFromKey(key);\n                let collection = this.datastore[collectionKey];\n                if (collection) {\n                    let rec=collection[id];\n                    collection[id]=null;\n                    if (!rec){\n                        if (done) done(\"no such object \"+key);\n                    } else {\n                        if (done) done(null);\n                    }\n                } else {\n                    if (done) done(\"no such object \"+key);\n                }\n            \n            }\n        })\n    }\n    FIND(typeCode:string, search:Query,done:(err:string,keys:string[],objs:DataObj[])=>void,\n            keysOnly:boolean,forceRequest:boolean,serverContext:ServerContext){\n\n        let colCode = DataObj.typeToCollection(typeCode);\n        let collection = this.datastore[colCode];\n        let rslt:string[]=[];\n        if (collection){\n            for (let id in collection){\n                let rec = collection[id];\n                let match=true;\n                for (let field in search){\n                    let srch = search[field];\n                    let recVal = rec[field];\n                    if (!this.matches(srch,recVal))\n                        match=false;\n                }\n                if (match)\n                    rslt.push(rec._t_+\"_\"+id);\n            }\n            if (keysOnly){\n                done(null,rslt,[]);\n            } else {\n                let dObjs:DataObj[] = [];\n                this.getFromKeys(rslt,0,dObjs,(objs:DataObj[])=>{\n                    done(null,rslt,objs);\n                },serverContext);\n            }\n        } else {\n            done(null,rslt,[]);\n        }\n\n    }\n    matches(srch:QueryValue, val:any):boolean{\n        return Query.matchesQV(srch,val)\n    }\n    cFIND(typeCode:string,search:Query,forceRequest?:boolean):string[]{\n\n        let colCode = DataObj.typeToCollection(typeCode);\n        let collection = this.datastore[colCode];\n        let rslt:string[]=[];\n        if (collection){\n            for (let id in collection){\n                let rec = collection[id];\n                let match=true;\n                for (let field in search){\n                    let val = search[field];\n                    let recVal = rec[field];\n                    if (!recVal || recVal!=val)\n                        match=false;\n                }\n                if (match)\n                    rslt.push(rec._t_+\"_\"+id);\n            }\n            return rslt;\n        } else {\n            return null;\n        }\n\n    }\n}","/// <reference path=\"DataSource.ts\"/>\n\nlet mongo = require(\"mongodb\");\nconst Binary = require('mongodb').Binary;\nconst fs = require('fs');\n\nclass MongoDataSource extends DataSource{\n    private db;\n    private dbName:string;\n    private port:number;\n    private collectionNames:{ [collectionCode:string]:string};\n    constructor(dbHost:string,port:number,dbName:string,dropCollections?:boolean,skipCreateCollections?:boolean){\n        super();\n        this.dbName=dbName;\n        this.port=port;\n        let mongoClient = mongo.MongoClient;\n        //let url = \"mongodb://localhost:27017/\";\n        //let url = \"mongodb://\"+dbHost+\":\"+port+\"/\"+dbName;\n        let url = \"mongodb://\"+dbHost+\":\"+port+\"/admin\";\n        DB.msg(\"mongodb url\",url);\n        this.collectionNames=null;\n        mongoClient.connect(url,{ useNewUrlParser: true,useUnifiedTopology: true },(err,db)=>{\n            if (err){\n                throw err;\n            }\n            DB.msg(\"MONGO created \");\n            this.db=db;\n            if (dropCollections)\n                this.dropCollections();\n            if (!skipCreateCollections)\n              this.createCollections();\n        })\n    }\n    private dropCollections(){\n        let dbo = this.db.db(this.dbName);\n        let collections = DataObj.collections();\n        if (collections){\n            for (let collCode in collections){\n                let ci = DataObj.classInfo[collCode];\n                if (ci){\n                    let collName = ci.className;\n                    dbo.collection(collName).drop(collName,(err,res)=>{\n                        if (err) DB.msg(\"ERR Drop \"+collName+\" \",err);\n                    })\n                }\n            }\n            \n        }\n    }\n    private createCollections(){\n        if (this.collectionNames) return;\n        let dbo = this.db.db(this.dbName);\n        let collections = DataObj.collections();\n        if (collections){\n            this.collectionNames={};\n            for (let collCode in collections){\n                let ci = DataObj.classInfo[collCode];\n                if (ci){\n                    let collName = DataObj.classInfo[collCode].className;\n                    this.collectionNames[collCode]=collName;\n                    dbo.createCollection(collName,(err,res)=>{\n                        if (err) throw err;\n                    })\n                }\n            }\n            \n        }\n    }\n    GET(key:string, done:(err:string,data:DataObj)=>void,forceRequest:boolean,serverContext:ServerContext){\n        let _this=this;\n        if (!key){\n            done(\"GET null key\",null);\n            return;\n        }\n        let collectionKey = DataSource.collectionFromKey(key);\n        let id = DataSource.idFromKey(key);\n        let collectionName:string = DataObj.classInfo[collectionKey].className;\n        let dbo=this.db.db(this.dbName);\n        let idQuery = { _id:new mongo.ObjectID(id) };\n        dbo.collection(collectionName).findOne(idQuery,(err,res)=>{\n            if (err) {\n                done(err,null);\n            } else if (res){\n                res._key = key;\n                let typeCode = DataSource.typeFromKey(key);\n                let dObj:DataObj = DataObj.make(typeCode,res);\n                dObj.dataSource = _this;\n                done(null,dObj);\n            } else {\n                done(\"No such object for \"+key,null);\n            }\n        })\n        \n    }\n    GETm(keys:string[], done:(err:string,data:DataObj[])=>void,forceRequest:boolean,serverContext:ServerContext){\n        this.multiGet(0,keys,[],done,forceRequest,serverContext);\n    }\n    private multiGet(idx:number,keys:string[],rslt:DataObj[],done:(err:string,data:DataObj[])=>void,forceRequest:boolean,serverContext:ServerContext){\n        \n        let _this=this;\n        if (idx>=keys.length) {\n            done(null,rslt);\n        } else {\n            this.GET(keys[idx],(err:string,data:DataObj)=>{\n                if (err) {\n                    done(err,rslt);\n                } else {\n                    rslt.push(data);\n                    data.dataSource=_this;\n                    this.multiGet(idx+1,keys,rslt,done,forceRequest,serverContext);\n                }\n            },forceRequest,serverContext);\n        }\n    }\n    PUT(obj:DataObj,done:(err:string,newObj:DataObj)=>void,serverContext:ServerContext){\n \n        let key = obj._key;\n        let dbo = this.db.db(this.dbName);\n        let jsonObj = obj.toJSON();\n        if (key){\n            // do an update\n            let collCode = DataSource.collectionFromKey(key);\n            let collName:string = DataObj.classInfo[collCode].className;\n            let id = DataSource.idFromKey(key);\n            let idQuery = { _id:new mongo.ObjectID(id) };\n            try{\n                dbo.collection(collName).replaceOne(idQuery,jsonObj,(err,res)=>{\n                    if (err){\n                        done(err,null);\n                    } else {\n                        done(null,obj);\n                    }\n                });\n            } catch (e){\n                done(e.toString(),null);\n            }\n\n        } else {\n            // do an insert\n            let typeCode = obj.getTypeCode();\n            let collCode:string = DataObj.typeToCollection(typeCode);\n            let collName:string = DataObj.classInfo[collCode].className;\n            dbo.collection(collName).insertOne(jsonObj,(err,res)=>{\n                if (err) {\n                    done(err,null);\n                } else {\n                    let newId = res.insertedId;\n                    obj._key = obj.getTypeCode()+\"_\"+newId;\n                    obj.dataSource=this;\n                    done(null,obj);\n                }\n            })\n        }\n    }\n    private static maxBlobSize=1000000;\n    PUTFileBlob(file:File,serverContext:ServerContext,done:(err:string,blobKey:string)=>void){\n        \n        try {\n            let data = fs.readFileSync((<any>file).path);\n            //let dataStr=data.toString();\n            //DB.msg(\"dataStr\",dataStr);\n            this.putDataBlob(data,file.name,file.type,(err:string,blobid:string)=>{\n                if (err){\n                    done(err,null);\n                } else {\n                    let fName = file.name;\n                    let fNameParts = fName.split(\".\")\n                    let key = \"BLOB_\"+blobid;\n                    if (fNameParts.length>1){\n                        key+=\".\"+fNameParts[1];\n                    }\n                    done(null,key)\n                }\n            })\n        } catch(e){}\n    }\n    PUTBlob(blob:Blob,name:string,serverContext:ServerContext,done:(err:string,blobKey:string)=>void){\n        try {\n            (<any>blob).arrayBuffer().then((buffer:Buffer)=>{\n                this.putDataBlob(buffer,name,blob.type,(putDBErr:string,blobid:string)=>{\n                    if (putDBErr){\n                        done(putDBErr,null);\n                    } else {\n                        let key=\"BLOB_\"+blobid;\n                        done(null,key);\n                    }\n                })\n            })\n        }catch(e){}\n    }\n    private putDataBlob(data:Buffer,fileName:string,fileType:string,done:(err:string,blobid:string)=>void){\n        if (data.length>MongoDataSource.maxBlobSize){\n            let dataFirst = data.slice(0,MongoDataSource.maxBlobSize);\n            let dataRest = data.slice(MongoDataSource.maxBlobSize);\n            this.putDataBlob(dataRest,fileName,fileType,(err:string,restBlobId:string)=>{\n                if (err){\n                    done(err,null);\n                } else {\n                    this.doMongoBlobPut(dataFirst,fileName,fileType,restBlobId,done);\n                }\n            })\n        } else {\n            this.doMongoBlobPut(data,fileName,fileType,null,done)\n        }\n    }\n    private doMongoBlobPut(data:Buffer,fileName:string,fileType:string,nextBlobId:string,done:(err:string,blobid:string)=>void){\n        let dbo=this.db.db(this.dbName);\n        let insertData:BlobStoreRec = { \n                name:fileName, type:fileType, \n                nextBlob:nextBlobId, \n                data: Binary(data)};\n\n        dbo.collection(\"BLOB\").insertOne(insertData,(err:string,rslt:any)=>{\n            if (err){\n                done(err,null);\n            } else {\n                let obj = rslt.ops[0];\n                let blobId=obj._id.toString();\n                done(null,blobId);\n            }\n        })\n    }\n    GETBlob(blobKey:string,serverContext:ServerContext,\n                done:(err:string,blobData:BlobStoreRec)=>void){\n        let id = blobKey.split(\"_\")[1];\n        let idParts = id.split(\".\");\n        if (idParts.length>1)\n            id = idParts[0];\n        this.getMongoBlob(id,(err:string,fileName:string,fileType:string,buffers:Buffer[])=>{\n            \n            if (err)\n                done(err,null);\n            else {\n                let dataBuffer = Buffer.concat(buffers);\n                let rsltData:BlobStoreRec = {\n                    name:fileName,\n                    type:fileType,\n                    data: new Binary(dataBuffer),\n                    _key:blobKey\n                }\n                done(null,rsltData);\n            }\n        })\n    }\n    private getMongoBlob(id:string,done:(err:string,fileName:string,fileType:string,buffers:Buffer[])=>void){\n        let getObj = { _id:new mongo.ObjectID(id) };\n        let dbo=this.db.db(this.dbName);\n        dbo.collection(\"BLOB\").findOne(getObj,(err,res)=>{\n            if (err) {\n                done(err,null,null,null);\n            } else if (res){\n                let firstData:Buffer = res.data.buffer;\n                if (res.nextBlob){\n                    this.getMongoBlob(res.nextBlob,(nErr:string,nFn:string,nFt:string,nBuffers:Buffer[])=>{\n                        if (nErr)\n                            done(nErr,null,null,null);\n                        else {\n                            let newBuffers:Buffer[] = [firstData].concat(nBuffers);\n                            done(null,nFn,nFt,newBuffers);\n                        }\n                    })\n                } else {\n                    done(null,res.name,res.type,[firstData])\n                }\n            } else {\n                done(\"No such object for \"+id,null,null,null)\n            }\n        })\n    }\n \n    PUTm(objs:DataObj[],done:(err:string,newObjs:DataObj[])=>void,serverContext:ServerContext){\n        this.multiPut(0,objs,[],done,serverContext);\n\n    }\n    private multiPut(idx:number,objs:DataObj[],rslt:DataObj[],done:(err:string,newObjs:DataObj[])=>void,serverContext:ServerContext){\n        \n        let _this=this;\n        if (idx>=objs.length){\n            done(null,rslt);\n        } else {\n            this.PUT(objs[idx],(err:string,data:DataObj)=>{\n                if (err){\n                    done(err,rslt);\n                } else {\n                    rslt.push(data);\n                    data.dataSource=_this;\n                    this.multiPut(idx+1,objs,rslt,done,serverContext);\n                }\n            },null)\n        }\n    }\n    DELETE(key:string,done?:(err:string)=>void){\n        let collectionKey = DataSource.collectionFromKey(key);\n        let collName:string = DataObj.classInfo[collectionKey].className;\n        let id = DataSource.idFromKey(key);\n        let dbo = this.db.db(this.dbName);\n        let myQuery = { _id:mongo.ObjectID(id) };\n        dbo.collection(collName).deleteOne(myQuery,(err,obj)=>{\n            if (err) {\n                if (done) done(err);\n            } else {\n                if (done) done(null);\n            }\n        })\n    }\n    FIND(typeCode:string, search:Query,done:(err:string,keys:string[],obj:DataObj[])=>void,\n            keysOnly:boolean,forceRequest:boolean,serverContext:ServerContext){\n        let collCode = DataObj.typeToCollection(typeCode);\n        let collName:string = DataObj.classInfo[collCode].className;\n        let dbo = this.db.db(this.dbName);\n        let mongoSearch = this.dataSearchToMongo(collCode,search);\n        \n        dbo.collection(collName).find(mongoSearch, { projection:{ _id:1, _t_: 1 }}).toArray((err,res)=>{\n            //DB.msg(`${collCode} ${collName}`,mongoSearch)\n            if (err) {\n                done(err,null,null);\n            } else {\n                let rslt:string[] = [];\n                for (let i in res){\n                    let key = res[i]._t_+\"_\"+res[i]._id;\n                    rslt.push(key);\n                }\n                if (keysOnly){\n                    done(null,rslt,[]);\n                } else {\n                    let dObjs:DataObj[] = [];\n                    this.getFromKeys(rslt,0,dObjs,(objs:DataObj[])=>{\n                        done(null,rslt,objs);\n                    },serverContext);\n                }\n            }\n        });\n    }\n    dataSearchToMongo(collectionCode:string,ds:Query):{}{\n        return ds.toMongo();\n        /*let ms:MongoSearchSpec = {};\n        for (let field in ds){\n            let fss = ds[field];\n            let isList = DataObj.classInfo[collectionCode].fields[field].isList;\n            let isDict = DataObj.classInfo[collectionCode].fields[field].isDict;\n            if (fss){\n                switch(typeof fss){\n                    case \"string\":\n                    case \"number\":\n                    case \"boolean\":\n                        if (isList){\n                            let s:MongoListSearchSpec = { $elemMatch:{$eq:fss}};\n                            ms[field]=s;\n                        } else {\n                            ms[field]=fss;\n                        }\n                        break;\n                    default: //DataSearchRangeSpec\n                        let s:MongoRangeSearchSpec={};\n                        let from = (<any>fss).from;\n                        if (from)\n                            s.$gte = from;\n                        let to = (<any>fss).to;\n                        if (to)\n                            s.$lte = to;\n                        if (isList){\n                            let ls:MongoListSearchSpec = {$elemMatch:s};\n                            ms[field]=ls;\n                        } else {\n                            ms[field]=s;\n                        }\n                        break;\n                }\n            }\n        }\n        return ms;*/\n    }\n}\ntype MongoRangeSearchSpec = { $gte?: number | string, $lte?: number | string};\ntype MongoItemEqual = {$eq: string | number | boolean }\ntype MongoListSearchSpec = { $elemMatch: MongoItemEqual | MongoRangeSearchSpec};\ntype MongoSearchSpec = { [fieldName:string]:string | number | boolean | MongoListSearchSpec | MongoRangeSearchSpec};","// <reference path=\"../zui/PageManager.ts\"/>\n\n\nabstract class ZingEnv{\n    env:any;\n    constructor(){\n        this.env={\n            serverPort:process.env.serverPort,\n            mongoHost:process.env.mongoHost,\n            mongoCredentials:process.env.mongoCredentials,\n            mongoPort:process.env.mongoPort,\n            mongoDB:process.env.mongoDB,\n            https:process.env.https\n        }\n    }\n    abstract indexHTML():string;\n    abstract pageHTML(root:string,pageName:string):string;\n\n    serverPort():number{\n        return parseInt(this.env.serverPort)\n    }\n\n    mongoHost():string{\n        return this.env.mongoHost;\n    }\n\n    mongoCredentials():string{\n        return this.env.mongoCredentials;\n    }\n\n    mongoPort():number{\n        return parseInt(this.env.mongoPort);\n    }\n\n    mongoDB():string{\n        return this.env.mongoDB;\n    }\n \n    serverStartNotice(){\n        DB.msg(`START SERVER @ ${this.serverPort()}`);\n        let cred = this.mongoCredentials();\n        if (!cred) \n            cred=\"\";\n        else\n            cred=\"user:pass@\"\n        DB.msg(`MONGO @ ${cred}${this.mongoHost()}:${this.mongoPort()}/${this.mongoDB()}`)\n    }\n    httpsServer():string{\n        return this.env.https;\n    }\n}","/// <reference path=\"MongoDataSource.ts\"/>\n/// <reference path=\"ZingEnv.ts\"/>\n\nconst  express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst formidable = require('formidable');\nconst https = require('https');\n\n\nclass ZingExpress {\n    app:any;\n    express;\n    dataSource:DataSource;\n    env:ZingEnv\n    constructor(dataSource:DataSource,env:ZingEnv){\n        this.dataSource=dataSource;\n        this.env=env;\n        this.setupServer();\n    }\n    extractQuery(query:any):any {\n        let rslt:any = {};\n        for ( let key in query){\n            if (key!=\"keysonly\"){\n                let val = decodeURI(query[key]);\n                rslt[key]=JSON.parse(val);\n                /*if (val.indexOf(`\"`)==0){\n                    val = val.substring(1,val.length-1);\n                    if (val.indexOf(`{`)==0){\n                        rslt[key] = this.parseRange(val);\n                    } else {\n                        rslt[key] = val;\n                    } \n                } else if (val.indexOf(`{`)==0){\n                    //rslt[key] = this.parseRange(val);\n                } else {\n                    switch(val){\n                        case \"true\":\n                            rslt[key]=true;\n                            break;\n                        case \"false\":\n                            rslt[key]=false;\n                            break;\n                        default:\n                            rslt[key] = Number.parseFloat(val);\n                            break;\n                    }\n                    \n                }*/\n            } else {\n                rslt.keysonly=query.keysonly;\n            }\n        }\n        return rslt;\n    }\n    private parseRange(val:string):{}{\n        let rslt:{from?:any,to?:any} = {};\n        let str = val.substring(1,val.length-1);\n        let parts = str.split(\",\");\n        let aParts = parts[0].split(\":\");\n        rslt[aParts[0]]=this.queryVal(aParts[1]);\n        if (parts.length>1){\n            aParts = parts[1].trim().split(\":\");\n            rslt[aParts[0]]=this.queryVal(aParts[1]);\n        }\n        return rslt;\n    }\n    private queryVal(val:string):any{\n        if (val.indexOf(`\"`)==0){\n            return val.substring(1,val.length-1);\n        } else if (val==\"true\"){\n            return true;\n        } else if (val==\"false\"){\n            return false;\n        } else {\n            return Number.parseInt(val);\n        }\n    }\n    private httpDebugMsg(req,res,next){\n        let request:string = `${req.method}: \"${req.protocol}://${req.hostname}${req.originalUrl}\" `;\n        DB.msg(request);\n        next();\n    }\n    private noCache(req,res,next){\n        res.set('Cache-Control','public,max-age=0');\n        next();\n    }\n    private setupServer(){\n        this.app = express();\n        //let ds = new MemDataSource();\n        let ds = this.dataSource;\n        this.app.use(bodyParser.urlencoded({ extended:false, limit:'50mb'}));\n        this.app.use(bodyParser.json({limit:'50mb'}));\n        this.app.use(cookieParser());\n\n        this.app.use(this.httpDebugMsg) // debugging assistance\n        this.app.use(this.noCache) // defeat all caching\n\n\n        this.app.get('/',(req,res)=>{\n            res.send(this.env.indexHTML())\n            //res.sendFile(__dirname+\"/war/index.html\");\n        })\n        this.app.get('/data/get/*',(req,res)=>{\n            //console.log(\"get request url\",req.url);\n            //console.log(\"      request params\",req.params);\n            //console.log(\"      request query\",req.query);\n\n            let key = req.params[0];\n            let sc = new ServerContext(req,res);\n            ds.canGet(key,sc,(granted:boolean)=>{\n                if (granted){\n                    ds.GET(key,(err:string,data:DataObj)=>{\n                        if (err){\n                            res.status(204).send();\n                        } else {\n                            let fdata = this.doGetFilter(data);\n                            let j = fdata.toJSON();\n                            let js= JSON.stringify(j);\n                            res.status(200).send(js);\n                        }\n                    },false,sc)\n                }\n            })\n            \n        });\n        this.app.post('/data/getm',(req,res)=>{\n            //console.log(\"getm request url\",req.url);\n            let rslt = req.body;\n            let keys:string[] = req.body.keys;\n            //console.log(\"      request body\",keys);\n            let sc = new ServerContext(req,res);\n            ds.canGETm(keys,sc,(granted:boolean)=>{\n                if (granted){\n                    ds.GETm(keys,(err:string,data:DataObj[])=>{\n                        if (err){\n                            res.status(200).send(\"[]\");\n                        } else {\n                            let rslt = [];\n                            for (let i in data){\n                                let obj = data[i];\n                                let fobj = this.doGetFilter(obj);\n                                rslt.push(fobj.toJSON());\n                            }\n                            let js=JSON.stringify(rslt);\n                            res.status(200).send(js);\n                        }\n                    },false,sc)\n                }\n            })\n        })\n        this.app.post('/data/put/*',(req,res)=>{\n            //console.log(\"put request url\",req.url);\n            let key = req.params[0];\n            let b = req.body;\n\n            //console.log(\"      request body\",req.body);\n            let tc = req.body._t_;\n            let obj = DataObj.make(tc,req.body);\n            \n            let sc = new ServerContext(req,res);\n            obj.PUT((err:string,newObj:DataObj)=>{\n                if (err){\n                    this.sendErr(res,err);\n                } else {\n                    let j = newObj.toJSON();\n                    let js = JSON.stringify(j);\n                    res.status(200).send(js);\n                }\n            },sc)\n        });\n        this.app.post(\"/createuser\",(req,res)=>{\n            let q = this.extractQuery(req.query);\n            let password = q.password;\n            let userDesc = req.body;\n            let rm = ds.getRightsManager();\n            let um = rm.userManager;\n            let sc = new ServerContext(req,res);\n            um.createUser(userDesc,password,(err:string)=>{\n                if (err){\n                    this.sendErr(res,err);\n                } else {\n                    res.status(200).send(\"\");\n                }\n            },sc)\n            console.log(\"createuser\")\n        })\n        this.app.post('/data/putm',(req,res)=>{\n            //console.log(\"putm request url\",req.url);\n            let jsonObjs = req.body;\n\n            //console.log(\"      request body\",jsonObjs);\n            let reqObjs:DataObj[] = [];\n            for (let i in jsonObjs){\n                let json = jsonObjs[i];\n                let obj = DataObj.make(null,json);\n                reqObjs.push(obj);\n            }\n\n            let sc = new ServerContext(req,res);\n            ds.canPUTm(reqObjs,sc,(granted:boolean)=>{\n                if (granted){\n                    ds.PUTm(reqObjs,(err:string,newObjs:DataObj[])=>{\n                        if (err){\n                            this.sendErr(res,err);\n                        } else {\n                            let rslt = [];\n                            for (let i in newObjs){\n                                let obj = newObjs[i];\n                                rslt.push(obj.toJSON());\n                            }\n                            let js=JSON.stringify(rslt);\n                            res.status(200).send(js);\n                        }\n                    },sc)\n                }\n            })\n            \n        })\n        \n        this.app.get('/data/find/*',(req,res)=>{\n            //console.log(\"find request url\",req.url);\n            let collectionCode = DataObj.typeToCollection(req.params[0]);\n            //console.log(\"     collection\",collectionCode);\n            //console.log(\"     query\",req.query);\n            let search = this.extractQuery(req.query);\n            let sc = new ServerContext(req,res);\n            let keysOnly=false;\n            if (req.query.keysonly){\n                keysOnly=true;\n            }\n            let searchQuery = Query.fromJSON(search.q);\n            ds.canFIND(collectionCode,<Query>searchQuery,sc,(granted:boolean)=>{\n                if (granted){\n                    ds.FIND(collectionCode,<Query>searchQuery,(err:string,keys:string[],objs:DataObj[])=>{\n                        let filteredKeys = DataSource.filterKeyList(collectionCode,keys);\n                        if (err){\n                            this.sendErr(res,err);\n                        } else {\n                            let rslt = {keys:filteredKeys, objs:objs};\n                            let js = JSON.stringify(rslt);\n                            res.status(200).send(js);\n                        }\n                    },keysOnly,false,sc)\n                } else {\n                    this.sendErr(res,\"Find failed rights check\");\n                }\n            })\n            \n        })\n        this.app.get('/login',(req,res)=>{\n            let rm = ds.getRightsManager();\n            let um = rm.userManager;\n            let q = this.extractQuery(req.query);\n            let userName = q.userName;\n            let password = q.password;\n            console.log(\"login\",userName);\n            um.serverSideLogin(userName,password,new ServerContext(req,res),(err:string,user:DataObj)=>{\n                if (err){\n                    this.sendErr(res,err);\n                } else {\n                    let json = user.toJSON();\n                    let stJson = JSON.stringify(json);\n                    res.status(200).send(stJson);\n                }\n            })\n        })\n        this.app.get('/logout',(req,res)=>{\n            let rm = ds.getRightsManager();\n            let um = rm.userManager;\n            console.log(\"logout\");\n            um.serverSideLogout(new ServerContext(req,res),(err:string)=>{\n                if (err){\n                    this.sendErr(res,err);\n                } else {\n                    res.status(200).send(\"logout\");\n                }\n            })\n        })\n        this.app.get('/blob/:key',(req,res)=>{\n            let key = req.params.key;\n            DB.msg(\"GET blob\",key);\n            let sc = new ServerContext(req,res);\n            ds.canGETBlob(key,sc,(granted:boolean)=>{\n                if (granted){\n                    ds.GETBlob(key,sc,(err:string,blob:BlobStoreRec)=>{\n                        if (err){\n                            this.sendErr(res,err);\n                        } else {\n                            let type = blob.type;\n                            res.set(\"Content-Type\",type).send(blob.data.buffer);\n                        }\n                    })\n                }\n            })\n            \n        })\n        this.app.post('/blob',(req,res)=>{\n            let form = new formidable.IncomingForm()\n            form.parse(req,(err,fields,files)=>{\n                DB.msg(\"fields\",fields);\n                DB.msg(\"files\",files);\n                if (files){\n                    let sc = new ServerContext(req,res);\n                    let data = null;\n                    if (files.file){\n                        data = files.file;\n                    } else {\n                        data = files.data;\n                    }\n                    if (data){\n                        ds.canPUTBlob(sc,(granted:boolean)=>{\n                            if (granted){\n                                ds.PUTFileBlob(data,sc,(err:string,blobKey:string)=>{\n                                    res.json({ blobKey:blobKey });\n                                })\n                            } else {\n                                this.sendErr(res,\"PutFileBlob permission failure\")\n                            }\n                        })\n                        \n                    } else {\n                        this.sendErr(res,\"PutFileBlob blob no data in files\")\n                    }\n                }  else {\n                    this.sendErr(res,\"No files present\");\n                }\n            })\n\n        })\n        this.app.delete('/data/delete/*',(req,res)=>{\n            //console.log(\"delete  request url\",req.url);\n            let parts:string[] = req.url.split(\"/delete/\");\n\n            let key = parts[1];\n            let sc = new ServerContext(req,res);\n            ds.canDELETE(key,sc,(granted:boolean)=>{\n                if (granted){\n                    ds.DELETE(key,(err:string)=>{\n                        if (err)\n                            this.sendErr(res,err);\n                        else{\n                            res.status(200).send();\n                        }\n                    })\n                }\n            })\n            \n            \n        })\n        this.app.get('*/pg/*',(req,res)=>{\n            let parts:string[] = req.url.split(\"/pg/\");\n            let root=parts[0];\n            if (root[0]==\"/\"){\n                root = root.substring(1);\n            }\n            let page=parts[1];\n            //DB.msg(`url=${req.url} dir=${__dirname} root=\"${root}\" page=\"${page}\"`);\n            //res.sendFile(__dirname+`/war/${root}/pagehandler.html`)\n            //res.sendFile(__dirname+\"/war/index.html\")\n            res.send(this.env.pageHTML(root,page));\n        })\n        this.app.use(express.static(__dirname + '/war'));\n    }\n    private sendErr(res,msg:string){\n        res.status(400).send(msg);\n    }\n    private doGetFilter_:(data:DataObj)=>DataObj = (obj:DataObj)=>{ return obj;}\n    private doGetFilter(data:DataObj):DataObj {\n        return this.doGetFilter_(data);\n    }\n    set getFilter(filterFunction:(obj:DataObj)=>DataObj){\n        this.doGetFilter_=filterFunction;\n    }\n    \n    get(pattern:string,handler:(req,res)=>void){\n        this.app.get(pattern,handler);\n    }\n    post(pattern:string,handler:(req,res)=>void){\n        this.app.post(pattern,handler);\n    }\n    listen(portNumber){\n        let httpsServer = this.env.httpsServer();\n        if (httpsServer){\n            let cert = {\n                key: fs.readFileSync(`${httpsServer}.key`),\n                cert: fs.readFileSync(`${httpsServer}.crt`)\n            }\n            let httpsApp = https.createServer(cert,this.app);\n            httpsApp.listen(portNumber,()=>{\n                DB.msg(\"start https\");\n            })\n        } else {\n            this.app.listen(portNumber);\n        }\n        \n    }\n}","\nclass ZPerson extends DataObj{\n   protected FirstName_:string;\n   protected LastName_:string;\n   protected Email_:string;\n   protected Phone_:string;\n   constructor(json:any){\n      super(json);\n      if (json.FirstName){\n         this.FirstName_=json.FirstName;\n      }\n      if (json.LastName){\n         this.LastName_=json.LastName;\n      }\n      if (json.Email){\n         this.Email_=json.Email;\n      }\n      if (json.Phone){\n         this.Phone_=json.Phone;\n      }\n   }\n   getTypeCode():string { return 'P';}\n   getFirstName():string {\n      return this.FirstName_;\n   }\n   setFirstName(newVal: string) {\n      if (this.FirstName_ != newVal){\n         this.FirstName_=newVal;\n         this.touch();\n      }\n   }\n   getLastName():string {\n      return this.LastName_;\n   }\n   setLastName(newVal: string) {\n      if (this.LastName_ != newVal){\n         this.LastName_=newVal;\n         this.touch();\n      }\n   }\n   getEmail():string {\n      return this.Email_;\n   }\n   setEmail(newVal: string) {\n      if (this.Email_ != newVal){\n         this.Email_=newVal;\n         this.touch();\n      }\n   }\n   getPhone():string {\n      return this.Phone_;\n   }\n   setPhone(newVal: string) {\n      if (this.Phone_ != newVal){\n         this.Phone_=newVal;\n         this.touch();\n      }\n   }\n   static GET(key:string,done:(err:string,data:Person)=>void,forceRequest?:boolean,serverContext?:ServerContext){\n      let tc=DataSource.typeFromKey(key);\n      if (!DataObj.checkTypeCode('P',tc)){ done(\"ERR wrong key \"+key+\" for Person.GET\",null);return}\n      super.GET(key,(err:string,data:DataObj)=>{\n         if (err){\n            done(err,null);\n         } else {\n            done(null,<Person>data);\n         }\n      },forceRequest,serverContext)\n   }\n   static cGET(key:string,forceRequest?:boolean):Person{\n      let tc=DataSource.typeFromKey(key);\n      if (!DataObj.checkTypeCode('P',tc)){ DB.msg(\"ERR wrong key \"+key+\" for Person.GET\",null); return null}\n      return <Person>(super.cGET(key,forceRequest));\n   }\n   static GETm(keys:string[],done:(err:string,data:Person[])=>void,forceRequest?:boolean,serverContext?:ServerContext){\n      if (!keys || keys.length==0){\n         done(null,[])\n         return\n      }\n      let tc=DataSource.typeFromKey(keys[0]);\n      if (!DataObj.checkTypeCode('P',tc)){ done(\"ERR wrong key \"+keys[0]+\" for Person.GETm\",null); return}\n      super.GETm(keys,(err:string,data:DataObj[])=>{\n         if (err){\n            done(err,null);\n         } else {\n            done(null,<Person[]>data);\n         }\n      },forceRequest,serverContext)\n   }\n   toJSON():any{\n      let rslt:any = {};\n      rslt._key=this._key\n      rslt._t_=\"P\";\n      rslt.FirstName=this.getFirstName();\n      rslt.LastName=this.getLastName();\n      rslt.Email=this.getEmail();\n      rslt.Phone=this.getPhone();\n      return rslt;\n   }\n   \n   static byName(FirstName:StringQuery,LastName:StringQuery,done:(err:string,keys:string[])=>void,keysOnly?:boolean,forceRequest?:boolean,serverContext?:ServerContext){\n      super.FIND(\"P\",Query.dict({FirstName:FirstName ,LastName:LastName }),done,keysOnly,forceRequest,serverContext)\n   }\n   \n   static byNameC(FirstName:StringQuery,LastName:StringQuery,keysOnly?:boolean,forceRequest?:boolean):string[]{\n      let ds = DataObj.globalSource;\n      return super.cFIND(\"P\",Query.dict({FirstName:FirstName ,LastName:LastName }),keysOnly,forceRequest)\n   }\n}\n","/// <reference path=\"ZPerson.ts\" />\n\nclass Person extends ZPerson {\n  getFullName() {\n    if (this.getFirstName() && this.getLastName()) {\n      return `${this.getFirstName()} ${this.getLastName}`\n    }\n  }\n\n  getDescription(includeEmail: boolean = false) {\n    if (includeEmail && this.getEmail()) {\n      return `${this.getFullName()} (${this.getEmail})`\n    }\n    return this.getFullName()\n  }\n\n  static allPersons(): string[] {\n    return super.cFIND(\"P\", Query.dict({}), false, false);\n  }\n}","/// <reference path=\"Person.ts\"/>\n\nclass ZTeam extends DataObj{\n   protected TeamName_:string;\n   protected SeasonLabel_:string;\n   protected Coach_:string;\n   protected AssistantCoach_:string;\n   protected TeamManager_:string;\n   constructor(json:any){\n      super(json);\n      if (json.TeamName){\n         this.TeamName_=json.TeamName;\n      }\n      if (json.SeasonLabel){\n         this.SeasonLabel_=json.SeasonLabel;\n      }\n      if (json.Coach){\n         this.Coach_=json.Coach;\n      } else {\n         this.Coach_=null;\n      }\n      if (json.AssistantCoach){\n         this.AssistantCoach_=json.AssistantCoach;\n      } else {\n         this.AssistantCoach_=null;\n      }\n      if (json.TeamManager){\n         this.TeamManager_=json.TeamManager;\n      } else {\n         this.TeamManager_=null;\n      }\n   }\n   getTypeCode():string { return 'T';}\n   getTeamName():string {\n      return this.TeamName_;\n   }\n   setTeamName(newVal: string) {\n      if (this.TeamName_ != newVal){\n         this.TeamName_=newVal;\n         this.touch();\n      }\n   }\n   getSeasonLabel():string {\n      return this.SeasonLabel_;\n   }\n   setSeasonLabel(newVal: string) {\n      if (this.SeasonLabel_ != newVal){\n         this.SeasonLabel_=newVal;\n         this.touch();\n      }\n   }\n   getCoach():string {\n      return this.Coach_;\n   }\n   setCoach(newVal: string) {\n      if (this.Coach_ != newVal){\n         this.Coach_=newVal;\n         this.touch();\n      }\n   }\n   getAssistantCoach():string {\n      return this.AssistantCoach_;\n   }\n   setAssistantCoach(newVal: string) {\n      if (this.AssistantCoach_ != newVal){\n         this.AssistantCoach_=newVal;\n         this.touch();\n      }\n   }\n   getTeamManager():string {\n      return this.TeamManager_;\n   }\n   setTeamManager(newVal: string) {\n      if (this.TeamManager_ != newVal){\n         this.TeamManager_=newVal;\n         this.touch();\n      }\n   }\n   static GET(key:string,done:(err:string,data:Team)=>void,forceRequest?:boolean,serverContext?:ServerContext){\n      let tc=DataSource.typeFromKey(key);\n      if (!DataObj.checkTypeCode('T',tc)){ done(\"ERR wrong key \"+key+\" for Team.GET\",null);return}\n      super.GET(key,(err:string,data:DataObj)=>{\n         if (err){\n            done(err,null);\n         } else {\n            done(null,<Team>data);\n         }\n      },forceRequest,serverContext)\n   }\n   static cGET(key:string,forceRequest?:boolean):Team{\n      let tc=DataSource.typeFromKey(key);\n      if (!DataObj.checkTypeCode('T',tc)){ DB.msg(\"ERR wrong key \"+key+\" for Team.GET\",null); return null}\n      return <Team>(super.cGET(key,forceRequest));\n   }\n   static GETm(keys:string[],done:(err:string,data:Team[])=>void,forceRequest?:boolean,serverContext?:ServerContext){\n      if (!keys || keys.length==0){\n         done(null,[])\n         return\n      }\n      let tc=DataSource.typeFromKey(keys[0]);\n      if (!DataObj.checkTypeCode('T',tc)){ done(\"ERR wrong key \"+keys[0]+\" for Team.GETm\",null); return}\n      super.GETm(keys,(err:string,data:DataObj[])=>{\n         if (err){\n            done(err,null);\n         } else {\n            done(null,<Team[]>data);\n         }\n      },forceRequest,serverContext)\n   }\n   toJSON():any{\n      let rslt:any = {};\n      rslt._key=this._key\n      rslt._t_=\"T\";\n      rslt.TeamName=this.getTeamName();\n      rslt.SeasonLabel=this.getSeasonLabel();\n      rslt.Coach=this.getCoach();\n      rslt.AssistantCoach=this.getAssistantCoach();\n      rslt.TeamManager=this.getTeamManager();\n      return rslt;\n   }\n   \n   static byName(TeamName:StringQuery,done:(err:string,keys:string[])=>void,keysOnly?:boolean,forceRequest?:boolean,serverContext?:ServerContext){\n      super.FIND(\"T\",Query.dict({TeamName:TeamName }),done,keysOnly,forceRequest,serverContext)\n   }\n   \n   static byNameC(TeamName:StringQuery,keysOnly?:boolean,forceRequest?:boolean):string[]{\n      let ds = DataObj.globalSource;\n      return super.cFIND(\"T\",Query.dict({TeamName:TeamName }),keysOnly,forceRequest)\n   }\n}\n","/// <reference path=\"ZTeam.ts\" />\n\nclass Team extends ZTeam {\n\n  static makeNew(name: string,\n    done: (err: string, team: Team) => void) {\n    let newTeam = new Team({ TeamName: name });\n    newTeam.PUT((err: string, team: Team) => {\n      done(err, team);\n    })\n  }\n\n\n  static allTeams(): string[] {\n    return super.cFIND(\"T\", Query.dict({}), false, false);\n  }\n}","/// <reference path=\"Person.ts\"/>\n\nclass ZPlayer extends DataObj{\n   protected Person_:string;\n   protected JerseyNumber_:number;\n   protected Position_:string;\n   protected SecondaryPosition_:string;\n   constructor(json:any){\n      super(json);\n      if (json.Person){\n         this.Person_=json.Person;\n      } else {\n         this.Person_=null;\n      }\n      if (json.JerseyNumber){\n         this.JerseyNumber_=json.JerseyNumber;\n      } else {\n         this.JerseyNumber_=0;\n      }\n      if (json.Position){\n         this.Position_=json.Position;\n      }\n      if (json.SecondaryPosition){\n         this.SecondaryPosition_=json.SecondaryPosition;\n      }\n   }\n   getTypeCode():string { return 'PL';}\n   getPerson():string {\n      return this.Person_;\n   }\n   setPerson(newVal: string) {\n      if (this.Person_ != newVal){\n         this.Person_=newVal;\n         this.touch();\n      }\n   }\n   getJerseyNumber():number {\n      return this.JerseyNumber_;\n   }\n   setJerseyNumber(newVal: number) {\n      if (this.JerseyNumber_ != newVal){\n         this.JerseyNumber_=newVal;\n         this.touch();\n      }\n   }\n   getPosition():string {\n      return this.Position_;\n   }\n   setPosition(newVal: string) {\n      if (this.Position_ != newVal){\n         this.Position_=newVal;\n         this.touch();\n      }\n   }\n   getSecondaryPosition():string {\n      return this.SecondaryPosition_;\n   }\n   setSecondaryPosition(newVal: string) {\n      if (this.SecondaryPosition_ != newVal){\n         this.SecondaryPosition_=newVal;\n         this.touch();\n      }\n   }\n   static GET(key:string,done:(err:string,data:Player)=>void,forceRequest?:boolean,serverContext?:ServerContext){\n      let tc=DataSource.typeFromKey(key);\n      if (!DataObj.checkTypeCode('PL',tc)){ done(\"ERR wrong key \"+key+\" for Player.GET\",null);return}\n      super.GET(key,(err:string,data:DataObj)=>{\n         if (err){\n            done(err,null);\n         } else {\n            done(null,<Player>data);\n         }\n      },forceRequest,serverContext)\n   }\n   static cGET(key:string,forceRequest?:boolean):Player{\n      let tc=DataSource.typeFromKey(key);\n      if (!DataObj.checkTypeCode('PL',tc)){ DB.msg(\"ERR wrong key \"+key+\" for Player.GET\",null); return null}\n      return <Player>(super.cGET(key,forceRequest));\n   }\n   static GETm(keys:string[],done:(err:string,data:Player[])=>void,forceRequest?:boolean,serverContext?:ServerContext){\n      if (!keys || keys.length==0){\n         done(null,[])\n         return\n      }\n      let tc=DataSource.typeFromKey(keys[0]);\n      if (!DataObj.checkTypeCode('PL',tc)){ done(\"ERR wrong key \"+keys[0]+\" for Player.GETm\",null); return}\n      super.GETm(keys,(err:string,data:DataObj[])=>{\n         if (err){\n            done(err,null);\n         } else {\n            done(null,<Player[]>data);\n         }\n      },forceRequest,serverContext)\n   }\n   toJSON():any{\n      let rslt:any = {};\n      rslt._key=this._key\n      rslt._t_=\"PL\";\n      rslt.Person=this.getPerson();\n      rslt.JerseyNumber=this.getJerseyNumber();\n      rslt.Position=this.getPosition();\n      rslt.SecondaryPosition=this.getSecondaryPosition();\n      return rslt;\n   }\n   \n   static byPerson(Person:string,done:(err:string,keys:string[])=>void,keysOnly?:boolean,forceRequest?:boolean,serverContext?:ServerContext){\n      super.FIND(\"PL\",Query.dict({Person:Person }),done,keysOnly,forceRequest,serverContext)\n   }\n   \n   static byPersonC(Person:string,keysOnly?:boolean,forceRequest?:boolean):string[]{\n      let ds = DataObj.globalSource;\n      return super.cFIND(\"PL\",Query.dict({Person:Person }),keysOnly,forceRequest)\n   }\n   \n   static byNumber(JerseyNumber:NumberQuery,done:(err:string,keys:string[])=>void,keysOnly?:boolean,forceRequest?:boolean,serverContext?:ServerContext){\n      super.FIND(\"PL\",Query.dict({JerseyNumber:JerseyNumber }),done,keysOnly,forceRequest,serverContext)\n   }\n   \n   static byNumberC(JerseyNumber:NumberQuery,keysOnly?:boolean,forceRequest?:boolean):string[]{\n      let ds = DataObj.globalSource;\n      return super.cFIND(\"PL\",Query.dict({JerseyNumber:JerseyNumber }),keysOnly,forceRequest)\n   }\n}\n","/// <reference path=\"ZPlayer.ts\" />\n\nclass Player extends ZPlayer {\n\n}","/// <reference path=\"Player.ts\"/>\n\nclass ZGameEvent extends DataObj{\n   protected EventType_:string;\n   protected Time_:number;\n   protected Player_:string;\n   protected HomeScoreIncreased_:boolean;\n   protected AwayScoreIncreased_:boolean;\n   constructor(json:any){\n      super(json);\n      if (json.EventType){\n         this.EventType_=json.EventType;\n      }\n      if (json.Time){\n         this.Time_=json.Time;\n      } else {\n         this.Time_=0;\n      }\n      if (json.Player){\n         this.Player_=json.Player;\n      } else {\n         this.Player_=null;\n      }\n      this.HomeScoreIncreased_=json.HomeScoreIncreased;\n      this.AwayScoreIncreased_=json.AwayScoreIncreased;\n   }\n   getTypeCode():string { return 'GE';}\n   getEventType():string {\n      return this.EventType_;\n   }\n   setEventType(newVal: string) {\n      if (this.EventType_ != newVal){\n         this.EventType_=newVal;\n         this.touch();\n      }\n   }\n   getTime():number {\n      return this.Time_;\n   }\n   setTime(newVal: number) {\n      if (this.Time_ != newVal){\n         this.Time_=newVal;\n         this.touch();\n      }\n   }\n   getPlayer():string {\n      return this.Player_;\n   }\n   setPlayer(newVal: string) {\n      if (this.Player_ != newVal){\n         this.Player_=newVal;\n         this.touch();\n      }\n   }\n   getHomeScoreIncreased():boolean {\n      return this.HomeScoreIncreased_;\n   }\n   setHomeScoreIncreased(newVal: boolean) {\n      if (this.HomeScoreIncreased_ != newVal){\n         this.HomeScoreIncreased_=newVal;\n         this.touch();\n      }\n   }\n   getAwayScoreIncreased():boolean {\n      return this.AwayScoreIncreased_;\n   }\n   setAwayScoreIncreased(newVal: boolean) {\n      if (this.AwayScoreIncreased_ != newVal){\n         this.AwayScoreIncreased_=newVal;\n         this.touch();\n      }\n   }\n   toJSON():any{\n      let rslt:any = {};\n      rslt._t_=\"GE\";\n      rslt.EventType=this.getEventType();\n      rslt.Time=this.getTime();\n      rslt.Player=this.getPlayer();\n      rslt.HomeScoreIncreased=this.getHomeScoreIncreased();\n      rslt.AwayScoreIncreased=this.getAwayScoreIncreased();\n      return rslt;\n   }\n}\n","/// <reference path=\"ZGameEvent.ts\" />\n\nclass GameEvent extends ZGameEvent {\n\n\n}","/// <reference path=\"Team.ts\"/>\n/// <reference path=\"GameEvent.ts\"/>\n\nclass ZGame extends DataObj{\n   protected Team_:string;\n   protected HomeGame_:boolean;\n   protected Date_:string;\n   protected StartTime_:number;\n   protected EndTime_:number;\n   protected WinResult_:string;\n   protected GameEvents_:GameEvent[];\n   constructor(json:any){\n      super(json);\n      if (json.Team){\n         this.Team_=json.Team;\n      } else {\n         this.Team_=null;\n      }\n      this.HomeGame_=json.HomeGame;\n      if (json.Date){\n         this.Date_=json.Date;\n      }\n      if (json.StartTime){\n         this.StartTime_=json.StartTime;\n      } else {\n         this.StartTime_=0;\n      }\n      if (json.EndTime){\n         this.EndTime_=json.EndTime;\n      } else {\n         this.EndTime_=0;\n      }\n      if (json.WinResult){\n         this.WinResult_=json.WinResult;\n      }\n      if (json.GameEvents){\n         this.GameEvents_=<GameEvent[]>(DataObj.makeList('GE',json.GameEvents,this));\n      } else {\n         this.GameEvents_=[];\n      }\n   }\n   getTypeCode():string { return 'G';}\n   getTeam():string {\n      return this.Team_;\n   }\n   setTeam(newVal: string) {\n      if (this.Team_ != newVal){\n         this.Team_=newVal;\n         this.touch();\n      }\n   }\n   getHomeGame():boolean {\n      return this.HomeGame_;\n   }\n   setHomeGame(newVal: boolean) {\n      if (this.HomeGame_ != newVal){\n         this.HomeGame_=newVal;\n         this.touch();\n      }\n   }\n   getDate():string {\n      return this.Date_;\n   }\n   setDate(newVal: string) {\n      if (this.Date_ != newVal){\n         this.Date_=newVal;\n         this.touch();\n      }\n   }\n   getStartTime():number {\n      return this.StartTime_;\n   }\n   setStartTime(newVal: number) {\n      if (this.StartTime_ != newVal){\n         this.StartTime_=newVal;\n         this.touch();\n      }\n   }\n   getEndTime():number {\n      return this.EndTime_;\n   }\n   setEndTime(newVal: number) {\n      if (this.EndTime_ != newVal){\n         this.EndTime_=newVal;\n         this.touch();\n      }\n   }\n   getWinResult():string {\n      return this.WinResult_;\n   }\n   setWinResult(newVal: string) {\n      if (this.WinResult_ != newVal){\n         this.WinResult_=newVal;\n         this.touch();\n      }\n   }\n   getGameEvents():GameEvent[] {\n      let tmp:GameEvent[] = [];\n      for (let i in this.GameEvents_){\n         tmp.push(this.GameEvents_[i]);\n      }\n      return tmp;\n   }\n   setGameEvents(val: GameEvent[]) {\n      let tmp:GameEvent[] = [];\n      for (let i in val){\n         tmp.push(val[i]);\n         val[i].parent=this;\n      }\n      this.GameEvents_ = tmp;\n      this.touch();\n   }\n   static GET(key:string,done:(err:string,data:Game)=>void,forceRequest?:boolean,serverContext?:ServerContext){\n      let tc=DataSource.typeFromKey(key);\n      if (!DataObj.checkTypeCode('G',tc)){ done(\"ERR wrong key \"+key+\" for Game.GET\",null);return}\n      super.GET(key,(err:string,data:DataObj)=>{\n         if (err){\n            done(err,null);\n         } else {\n            done(null,<Game>data);\n         }\n      },forceRequest,serverContext)\n   }\n   static cGET(key:string,forceRequest?:boolean):Game{\n      let tc=DataSource.typeFromKey(key);\n      if (!DataObj.checkTypeCode('G',tc)){ DB.msg(\"ERR wrong key \"+key+\" for Game.GET\",null); return null}\n      return <Game>(super.cGET(key,forceRequest));\n   }\n   static GETm(keys:string[],done:(err:string,data:Game[])=>void,forceRequest?:boolean,serverContext?:ServerContext){\n      if (!keys || keys.length==0){\n         done(null,[])\n         return\n      }\n      let tc=DataSource.typeFromKey(keys[0]);\n      if (!DataObj.checkTypeCode('G',tc)){ done(\"ERR wrong key \"+keys[0]+\" for Game.GETm\",null); return}\n      super.GETm(keys,(err:string,data:DataObj[])=>{\n         if (err){\n            done(err,null);\n         } else {\n            done(null,<Game[]>data);\n         }\n      },forceRequest,serverContext)\n   }\n   toJSON():any{\n      let rslt:any = {};\n      rslt._key=this._key\n      rslt._t_=\"G\";\n      rslt.Team=this.getTeam();\n      rslt.HomeGame=this.getHomeGame();\n      rslt.Date=this.getDate();\n      rslt.StartTime=this.getStartTime();\n      rslt.EndTime=this.getEndTime();\n      rslt.WinResult=this.getWinResult();\n      rslt.GameEvents=[];\n      let tmp_GameEvents=this.getGameEvents()\n      for (let i in tmp_GameEvents){\n         rslt.GameEvents.push((tmp_GameEvents[i]).toJSON());\n      }\n      return rslt;\n   }\n   \n   static byDate(Date:StringQuery,done:(err:string,keys:string[])=>void,keysOnly?:boolean,forceRequest?:boolean,serverContext?:ServerContext){\n      super.FIND(\"G\",Query.dict({Date:Date }),done,keysOnly,forceRequest,serverContext)\n   }\n   \n   static byDateC(Date:StringQuery,keysOnly?:boolean,forceRequest?:boolean):string[]{\n      let ds = DataObj.globalSource;\n      return super.cFIND(\"G\",Query.dict({Date:Date }),keysOnly,forceRequest)\n   }\n   \n   static byHome(HomeGame:boolean,done:(err:string,keys:string[])=>void,keysOnly?:boolean,forceRequest?:boolean,serverContext?:ServerContext){\n      super.FIND(\"G\",Query.dict({HomeGame:HomeGame }),done,keysOnly,forceRequest,serverContext)\n   }\n   \n   static byHomeC(HomeGame:boolean,keysOnly?:boolean,forceRequest?:boolean):string[]{\n      let ds = DataObj.globalSource;\n      return super.cFIND(\"G\",Query.dict({HomeGame:HomeGame }),keysOnly,forceRequest)\n   }\n   \n   static byWinResult(WinResult:StringQuery,done:(err:string,keys:string[])=>void,keysOnly?:boolean,forceRequest?:boolean,serverContext?:ServerContext){\n      super.FIND(\"G\",Query.dict({WinResult:WinResult }),done,keysOnly,forceRequest,serverContext)\n   }\n   \n   static byWinResultC(WinResult:StringQuery,keysOnly?:boolean,forceRequest?:boolean):string[]{\n      let ds = DataObj.globalSource;\n      return super.cFIND(\"G\",Query.dict({WinResult:WinResult }),keysOnly,forceRequest)\n   }\n}\n","/// <reference path=\"ZGame.ts\"/>\n\nclass Game extends ZGame {\n\n}","/// <reference path=\"Team.ts\"/>\n/// <reference path=\"Person.ts\"/>\n/// <reference path=\"Player.ts\"/>\n/// <reference path=\"Game.ts\"/>\n/// <reference path=\"GameEvent.ts\"/>\n\nfunction ZMake(expectedType:string,json:any):DataObj {\n   let type:string=json._t_;\n   if (!DataObj.checkTypeCode(expectedType,type)){\n      console.log('ERR expecting '+expectedType+' got '+type,json);\n      return null\n   }\n   if (!type){\n      type=expectedType;\n   }\n   switch(type){\n      \n      case \"T\":\n         return new Team(json);\n      case \"P\":\n         return new Person(json);\n      case \"PL\":\n         return new Player(json);\n      case \"G\":\n         return new Game(json);\n      case \"GE\":\n         return new GameEvent(json);\n      default:\n         console.log('ERR bad typeCode '+type+' on',json);\n         return null\n      \n   }\n   return null;\n}\nDataObj.make=ZMake;\nfunction ZMakeList(expectedType:string,json:any[],parent:DataObj):DataObj[] {\n   let rslt:DataObj[] = [];\n   for (let i in json){\n      let obj:DataObj = ZMake(expectedType,json[i]);\n      obj.parent=parent;\n      rslt.push(obj); \n   }\n   return rslt;\n}\nDataObj.makeList=ZMakeList;\nfunction ZMakeDict(expectedType:string,json:any,parent:DataObj):{[k:string]:DataObj} {\n   let rslt:{[k:string]:DataObj}={};\n   for (let k in json){\n      let obj:DataObj = ZMake(expectedType,json[k]);\n      obj.parent=parent;\n      rslt[k]=obj; \n   }\n   return rslt;\n}\nDataObj.makeDict=ZMakeDict;\n\nDataObj.classInfo={\n   \"T\":{ \"className\":\"Team\",\"superCode\":\"\", \"keyed\":true,\n      fields: {\n         TeamName:{ type:\"string\", isList:false, isDict:false},\n         SeasonLabel:{ type:\"string\", isList:false, isDict:false},\n         Coach:{ type:\"Person\", isList:false, isDict:false},\n         AssistantCoach:{ type:\"Person\", isList:false, isDict:false},\n         TeamManager:{ type:\"Person\", isList:false, isDict:false},\n      },\n   },\n   \"P\":{ \"className\":\"Person\",\"superCode\":\"\", \"keyed\":true,\n      fields: {\n         FirstName:{ type:\"string\", isList:false, isDict:false},\n         LastName:{ type:\"string\", isList:false, isDict:false},\n         Email:{ type:\"string\", isList:false, isDict:false},\n         Phone:{ type:\"string\", isList:false, isDict:false},\n      },\n   },\n   \"PL\":{ \"className\":\"Player\",\"superCode\":\"\", \"keyed\":true,\n      fields: {\n         Person:{ type:\"Person\", isList:false, isDict:false},\n         JerseyNumber:{ type:\"number\", isList:false, isDict:false},\n         Position:{ type:\"string\", isList:false, isDict:false},\n         SecondaryPosition:{ type:\"string\", isList:false, isDict:false},\n      },\n   },\n   \"G\":{ \"className\":\"Game\",\"superCode\":\"\", \"keyed\":true,\n      fields: {\n         Team:{ type:\"Team\", isList:false, isDict:false},\n         HomeGame:{ type:\"boolean\", isList:false, isDict:false},\n         Date:{ type:\"string\", isList:false, isDict:false},\n         StartTime:{ type:\"number\", isList:false, isDict:false},\n         EndTime:{ type:\"number\", isList:false, isDict:false},\n         WinResult:{ type:\"string\", isList:false, isDict:false},\n         GameEvents:{ type:\"GameEvent\", isList:true, isDict:false},\n      },\n   },\n   \"GE\":{ \"className\":\"GameEvent\",\"superCode\":\"\", \"keyed\":false,\n      fields: {\n         EventType:{ type:\"string\", isList:false, isDict:false},\n         Time:{ type:\"number\", isList:false, isDict:false},\n         Player:{ type:\"Player\", isList:false, isDict:false},\n         HomeScoreIncreased:{ type:\"boolean\", isList:false, isDict:false},\n         AwayScoreIncreased:{ type:\"boolean\", isList:false, isDict:false},\n      },\n   },\n}\n","/// <reference path=\"../aaswZing/Zing/data/ZingEnv.ts\"/>\n\nclass SoccerStatsEnv extends ZingEnv {\n  indexHTML(): string {\n    return `\n      <html>\n          <head>\n              <script\n                  src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\"\n                  integrity=\"sha256-3edrmyuQ0w65f8gfBsqowzjJe2iM6n0nKciPUp8y+7E=\"\n                  crossorigin=\"anonymous\">\n              </script>\n              <link rel=\"stylesheet\" type=\"text/css\" href=\"/main.css\"/>\n          </head>\n          <body>\n              <div id=\"content\"></div>\n              <script src=\"/client.js\"></script>\n              <div id=\"modaloverlay\" class=\"hidden\"></div>\n          </body>\n      </html>\n      `\n  }\n  pageHTML(root: string, pageName: string): string {\n    return this.indexHTML();\n  }\n  serverPort() {\n    return parseInt(process.env.SERVER_PORT || \"4000\");\n  }\n  mongoDB(): string { return process.env.MONGO_DB_NAME; }\n  mongoCredentials(): string { return process.env.MONGO_DB_CREDS; }\n  mongoHost(): string { return process.env.MONGO_DB_HOST; }\n  mongoPort(): number { return parseInt(process.env.MONGO_DB_PORT || \"27017\"); }\n}","\n/// <reference path=\"../../aaswZing/Zing/data/RightsManager.ts\"/>\n/// <reference path=\"../../aaswZing/Zing/data/UserManager.ts\"/>\n\nclass AllRightsManager extends RightsManager {\n  constructor(dataSource: DataSource, userManager = new NoUserManager()) {\n    super(dataSource, userManager);\n  }\n  checkGET(key: string, serverContext: ServerContext, done: (granted: boolean) => void) {\n    done(true);\n  }\n\n  checkGETBlob(blobKey: string, serverContext, done: (granted: boolean) => void) {\n    done(true);\n  }\n  checkPUT(obj: DataObj, serverContext: ServerContext, done: (granted: boolean) => void) {\n    done(true);\n  }\n\n  checkPUTBlob(serverContext: ServerContext, done: (granted: boolean) => void) {\n    done(true);\n  }\n  checkDELETE(key: string, serverContext: ServerContext, done: (granted: boolean) => void) {\n    done(true);\n  }\n  checkFIND(typeCode: string, search: Query, serverContext: ServerContext, done: (granted: boolean) => void) {\n    done(true);\n  }\n}\n\nclass NoUserManager extends UserManager {\n  login(userName: string, password: string, done: (err: string, user: DataObj) => void,\n    serverContext: ServerContext) {\n    done(null, null);\n  }\n\n  getUserKey(serverContext?: ServerContext): string {\n    return \"anonymous\";\n  }\n\n}","\n/// <reference path=\"../../aaswZing/Zing/data/serverRefs.ts\"/>\n/// <reference path=\"../models/ZMake.ts\"/>\n/// <reference path=\"../SoccerStatsEnv.ts\"/>\n/// <reference path=\"../common/AllRightsManager.ts\"/>\nrequire(\"dotenv\").config();\n\nlet env = new SoccerStatsEnv();\nlet dataSource = new MongoDataSource(\n  env.mongoCredentials() + (env.mongoCredentials() ? \"@\" : \"\") + env.mongoHost(),\n  env.mongoPort(),\n  env.mongoDB(),\n  false,\n  true\n);\nlet rightsManager = new AllRightsManager(dataSource);\ndataSource.setRightsManager(rightsManager);\n\nlet app = new ZingExpress(dataSource, env);\n\nenv.serverStartNotice();\napp.listen(env.serverPort());\n","/// <reference path=\"DataObj.ts\"/>\n/// <reference path=\"MemDataSource.ts\"/>\n/// <reference path=\"MongoDataSource.ts\"/>\n/// <reference path=\"ZingExpress.ts\"/>\n"]}